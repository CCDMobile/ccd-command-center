<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CCD Sync Hub v3.2.2 - Improved Persistence</title>
    <link href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;600;700&family=JetBrains+Mono:wght@400&display=swap" rel="stylesheet">
    
    <!-- Shared File Helper (inline for standalone compatibility) -->
    <script>
    const CCDSharedFiles = (function() {
        const SHARED_DB_NAME = 'ccd-shared-files';
        const SHARED_DB_VERSION = 1;
        const SHARED_STORE_NAME = 'file-handles';
        let db = null;
        
        async function initDB() {
            if (db) return db;
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(SHARED_DB_NAME, SHARED_DB_VERSION);
                request.onerror = () => resolve(null);
                request.onsuccess = () => { db = request.result; resolve(db); };
                request.onupgradeneeded = (e) => {
                    const database = e.target.result;
                    if (!database.objectStoreNames.contains(SHARED_STORE_NAME)) {
                        database.createObjectStore(SHARED_STORE_NAME);
                    }
                };
            });
        }
        
        async function getHandle(key) {
            try {
                await initDB();
                if (!db) return null;
                return new Promise((resolve) => {
                    const tx = db.transaction([SHARED_STORE_NAME], 'readonly');
                    const store = tx.objectStore(SHARED_STORE_NAME);
                    const request = store.get(key);
                    request.onsuccess = async () => {
                        const handle = request.result;
                        if (!handle) { resolve(null); return; }
                        try {
                            const perm = await handle.queryPermission({ mode: 'readwrite' });
                            resolve(perm === 'granted' ? handle : null);
                        } catch (e) { resolve(null); }
                    };
                    request.onerror = () => resolve(null);
                });
            } catch (e) { return null; }
        }
        
        return {
            getMasterJson: () => getHandle('masterJson'),
            getSyncData: () => getHandle('syncData'),
            getConfigFile: () => getHandle('configFile'),
            getOneDriveFolder: () => getHandle('oneDriveFolder')
        };
    })();
    </script>
    
    <style>
        :root {
            --bg-dark: #0c1222; --bg-card: #141d2f; --bg-input: #1a2540; --bg-hover: #1e2d4a;
            --border: #2a3f5f; --text: #e2e8f0; --text-dim: #8892a6; --text-muted: #5a6478;
            --etsy: #f56400; --etsy-bg: rgba(245,100,0,0.15);
            --wix: #0061ff; --wix-bg: rgba(0,97,255,0.15);
            --wayfair: #9333ea; --wayfair-bg: rgba(147,51,234,0.15);
            --success: #22c55e; --success-bg: rgba(34,197,94,0.15);
            --warning: #eab308; --error: #ef4444; --info: #3b82f6;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'DM Sans', sans-serif; background: var(--bg-dark); color: var(--text); min-height: 100vh; }
        
        .header { background: var(--bg-card); border-bottom: 1px solid var(--border); padding: 0 24px; height: 60px; display: flex; align-items: center; justify-content: space-between; position: sticky; top: 0; z-index: 100; }
        .header-left { display: flex; align-items: center; gap: 16px; }
        .logo { display: flex; align-items: center; gap: 10px; font-weight: 700; font-size: 1.1rem; }
        .logo-icon { width: 36px; height: 36px; background: linear-gradient(135deg, #8b5cf6, #6366f1); border-radius: 8px; display: flex; align-items: center; justify-content: center; font-size: 1.2rem; }
        .header-nav { display: flex; gap: 4px; margin-left: 32px; }
        .nav-btn { padding: 8px 16px; border-radius: 6px; border: none; background: transparent; color: var(--text-dim); font-family: inherit; font-size: 0.9rem; font-weight: 500; cursor: pointer; transition: all 0.2s; }
        .nav-btn:hover { background: var(--bg-hover); color: var(--text); }
        .nav-btn.active { background: var(--bg-input); color: var(--text); }
        .header-right { display: flex; align-items: center; gap: 12px; }
        
        .btn { padding: 8px 16px; border-radius: 6px; border: none; font-family: inherit; font-size: 0.85rem; font-weight: 600; cursor: pointer; display: inline-flex; align-items: center; gap: 6px; transition: all 0.2s; }
        .btn-primary { background: linear-gradient(135deg, #8b5cf6, #6366f1); color: white; }
        .btn-primary:hover { transform: translateY(-1px); box-shadow: 0 4px 12px rgba(139,92,246,0.4); }
        .btn-secondary { background: var(--bg-input); color: var(--text); border: 1px solid var(--border); }
        .btn-secondary:hover { background: var(--bg-hover); }
        .btn-success { background: var(--success); color: white; }
        .btn-danger { background: var(--error); color: white; }
        .btn-sm { padding: 6px 12px; font-size: 0.8rem; }
        
        .container { max-width: 1400px; margin: 0 auto; padding: 24px; }
        .view { display: none; }
        .view.active { display: block; }
        
        .stats-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; margin-bottom: 24px; }
        .stat-card { background: var(--bg-card); border: 1px solid var(--border); border-radius: 12px; padding: 20px; }
        .stat-card-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px; }
        .stat-label { font-size: 0.85rem; color: var(--text-dim); text-transform: uppercase; letter-spacing: 0.5px; }
        .stat-icon { font-size: 1.5rem; opacity: 0.7; }
        .stat-value { font-size: 2rem; font-weight: 700; margin-bottom: 4px; }
        .stat-subtext { font-size: 0.8rem; color: var(--text-dim); }
        
        .card { background: var(--bg-card); border: 1px solid var(--border); border-radius: 12px; padding: 24px; margin-bottom: 24px; }
        .card-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 20px; padding-bottom: 16px; border-bottom: 1px solid var(--border); }
        .card-title { font-size: 1.2rem; font-weight: 600; }
        
        .queue-item { background: var(--bg-input); border: 1px solid var(--border); border-radius: 8px; padding: 16px; margin-bottom: 12px; display: flex; align-items: center; gap: 16px; }
        .queue-status { width: 12px; height: 12px; border-radius: 50%; flex-shrink: 0; }
        .queue-status.pending { background: var(--warning); animation: pulse 2s infinite; }
        .queue-status.processing { background: var(--info); animation: spin 1s linear infinite; }
        .queue-status.completed { background: var(--success); }
        .queue-status.failed { background: var(--error); }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
        @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
        
        .queue-info { flex: 1; }
        .queue-product { font-weight: 600; margin-bottom: 4px; }
        .queue-details { font-size: 0.85rem; color: var(--text-dim); }
        .queue-channel { display: inline-block; padding: 2px 8px; border-radius: 4px; font-size: 0.75rem; font-weight: 600; margin-right: 8px; }
        .queue-channel.etsy { background: var(--etsy-bg); color: var(--etsy); }
        .queue-channel.wix { background: var(--wix-bg); color: var(--wix); }
        .queue-channel.wayfair { background: var(--wayfair-bg); color: var(--wayfair); }
        
        .queue-actions { display: flex; gap: 8px; }

        /* Order items */
        .order-item { background: var(--bg-input); border: 1px solid var(--border); border-radius: 8px; padding: 16px; margin-bottom: 12px; }
        .order-item.processed { opacity: 0.6; }
        .order-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px; }
        .order-id { font-weight: 600; font-size: 1rem; }
        .order-channel { display: inline-block; padding: 4px 10px; border-radius: 4px; font-size: 0.75rem; font-weight: 600; }
        .order-channel.etsy { background: var(--etsy-bg); color: var(--etsy); }
        .order-channel.wix { background: var(--wix-bg); color: var(--wix); }
        .order-channel.wayfair { background: var(--wayfair-bg); color: var(--wayfair); }
        .order-meta { font-size: 0.85rem; color: var(--text-dim); margin-bottom: 12px; display: flex; gap: 16px; flex-wrap: wrap; }
        .order-items { border-top: 1px solid var(--border); padding-top: 12px; }
        .order-line { display: flex; justify-content: space-between; padding: 8px 0; border-bottom: 1px dashed var(--border); }
        .order-line:last-child { border-bottom: none; }
        .order-line-sku { font-family: 'JetBrains Mono', monospace; font-size: 0.85rem; color: var(--text-dim); }
        .order-line-qty { font-weight: 600; color: var(--warning); }
        .order-actions { margin-top: 12px; display: flex; gap: 8px; }
        
        /* Low stock item */
        .lowstock-item { display: flex; align-items: center; justify-content: space-between; padding: 12px 16px; border-bottom: 1px solid var(--border); }
        .lowstock-item:last-child { border-bottom: none; }
        .lowstock-sku { font-family: 'JetBrains Mono', monospace; font-weight: 600; }
        .lowstock-name { color: var(--text-dim); font-size: 0.85rem; }
        .lowstock-qty { display: flex; gap: 16px; align-items: center; }
        .lowstock-current { font-size: 1.2rem; font-weight: 700; color: var(--error); }
        .lowstock-par { font-size: 0.85rem; color: var(--text-dim); }
        
        .connection-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 16px; margin-bottom: 24px; }
        .connection-card { background: var(--bg-input); border: 1px solid var(--border); border-radius: 8px; padding: 16px; display: flex; align-items: center; gap: 12px; }
        .connection-icon { width: 40px; height: 40px; border-radius: 8px; display: flex; align-items: center; justify-content: center; font-size: 1.2rem; flex-shrink: 0; }
        .connection-icon.etsy { background: var(--etsy-bg); color: var(--etsy); }
        .connection-icon.wix { background: var(--wix-bg); color: var(--wix); }
        .connection-icon.wayfair { background: var(--wayfair-bg); color: var(--wayfair); }
        .connection-icon.shippo { background: rgba(72,187,120,0.15); color: var(--success); }
        .connection-info { flex: 1; }
        .connection-name { font-weight: 600; margin-bottom: 4px; }
        .connection-status { font-size: 0.8rem; color: var(--text-dim); }
        .connection-dot { width: 8px; height: 8px; border-radius: 50%; margin-right: 6px; display: inline-block; }
        .connection-dot.connected { background: var(--success); }
        .connection-dot.disconnected { background: var(--error); }
        
        .form-group { margin-bottom: 20px; }
        .form-label { display: block; font-size: 0.85rem; font-weight: 600; color: var(--text-dim); margin-bottom: 8px; text-transform: uppercase; letter-spacing: 0.5px; }
        .form-input { width: 100%; padding: 10px 12px; background: var(--bg-input); border: 1px solid var(--border); border-radius: 6px; color: var(--text); font-family: inherit; font-size: 0.9rem; }
        .form-input:focus { outline: none; border-color: #8b5cf6; }
        .form-checkbox { display: flex; align-items: center; gap: 8px; cursor: pointer; }
        .form-checkbox input { cursor: pointer; }
        
        .activity-log { max-height: 400px; overflow-y: auto; }
        .log-entry { padding: 12px; border-bottom: 1px solid var(--border); font-size: 0.85rem; }
        .log-entry:last-child { border-bottom: none; }
        .log-time { color: var(--text-muted); font-size: 0.75rem; margin-bottom: 4px; }
        .log-message { color: var(--text-dim); }
        .log-success { color: var(--success); }
        .log-error { color: var(--error); }
        
        .toast-container { position: fixed; bottom: 24px; right: 24px; z-index: 2000; display: flex; flex-direction: column; gap: 8px; max-width: 400px; }
        .toast { background: var(--bg-card); border: 1px solid var(--border); border-radius: 8px; padding: 12px 16px; display: flex; align-items: center; gap: 10px; box-shadow: 0 8px 24px rgba(0,0,0,0.4); animation: slideIn 0.3s ease; }
        @keyframes slideIn { from { transform: translateX(100%); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
        .toast.success { border-left: 3px solid var(--success); }
        .toast.error { border-left: 3px solid var(--error); }
        .toast.warning { border-left: 3px solid var(--warning); }
        .toast.info { border-left: 3px solid var(--info); }
        
        .empty-state { text-align: center; padding: 60px 20px; color: var(--text-dim); }
        .empty-state-icon { font-size: 4rem; margin-bottom: 16px; opacity: 0.5; }
        .empty-state-title { font-size: 1.2rem; font-weight: 600; margin-bottom: 8px; }
        
        .action-badge { display: inline-block; padding: 2px 6px; border-radius: 3px; font-size: 0.7rem; font-weight: 600; margin-left: 6px; }
        .action-badge.create { background: var(--success-bg); color: var(--success); }
        .action-badge.update { background: rgba(59,130,246,0.15); color: var(--info); }
        .action-badge.delete { background: rgba(239,68,68,0.15); color: var(--error); }

        /* Collapsible Notification Groups */
        .event-group { margin-bottom: 15px; border: 1px solid var(--border); border-radius: 8px; overflow: hidden; }
        .event-group-header { display: flex; align-items: center; justify-content: space-between; padding: 12px 15px; background: var(--bg-input); cursor: pointer; user-select: none; transition: background 0.2s; }
        .event-group-header:hover { background: var(--bg-hover); }
        .event-group-title { display: flex; align-items: center; gap: 10px; font-weight: 600; font-size: 14px; }
        .event-group-title .icon { font-size: 18px; }
        .event-group-badge { background: var(--bg-hover); color: var(--text-dim); padding: 2px 8px; border-radius: 10px; font-size: 11px; font-weight: normal; }
        .event-group-toggle { color: var(--text-dim); font-size: 12px; transition: transform 0.3s; }
        .event-group.collapsed .event-group-toggle { transform: rotate(-90deg); }
        .event-group-content { max-height: 500px; overflow: hidden; transition: max-height 0.3s ease-out; background: var(--bg-card); }
        .event-group.collapsed .event-group-content { max-height: 0; }
        .event-row { display: flex; align-items: center; justify-content: space-between; padding: 12px 15px; border-bottom: 1px solid var(--border); }
        .event-row:last-child { border-bottom: none; }
        .event-info { flex: 1; }
        .event-info .name { color: var(--text); font-weight: 500; }
        .event-info .desc { color: var(--text-dim); font-size: 12px; margin-top: 3px; }
        .event-select { width: 130px; padding: 6px 10px; background: var(--bg-input); border: 1px solid var(--border); border-radius: 6px; color: var(--text); font-size: 13px; }
        .group-sales .event-group-header { border-left: 4px solid var(--success); }
        .group-stock .event-group-header { border-left: 4px solid var(--warning); }
        .group-wayfair .event-group-header { border-left: 4px solid var(--wayfair); }
        .group-sync .event-group-header { border-left: 4px solid var(--info); }
        .group-errors .event-group-header { border-left: 4px solid var(--error); }
        .group-shipping .event-group-header { border-left: 4px solid var(--text-dim); }

        /* Error Panel */
        .error-panel { background: rgba(239,68,68,0.1); border: 1px solid var(--error); border-radius: 8px; padding: 16px; margin-bottom: 20px; display: none; }
        .error-panel.visible { display: block; }
        .error-panel-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px; }
        .error-panel-title { color: var(--error); font-weight: 600; font-size: 1rem; }
        .error-panel-content { font-size: 0.85rem; color: var(--text); max-height: 200px; overflow-y: auto; }
        .error-item { padding: 8px; background: rgba(0,0,0,0.2); border-radius: 4px; margin-bottom: 8px; font-family: monospace; font-size: 0.8rem; }

        /* Shared Configuration Status Styles */
        .config-status-banner { padding: 16px; border-radius: 8px; margin-bottom: 20px; }
        .config-status-banner.connected { background: rgba(34,197,94,0.15); border: 1px solid var(--success); }
        .config-status-banner.disconnected { background: rgba(234,179,8,0.15); border: 1px solid var(--warning); }
        .config-status-dot { width: 10px; height: 10px; border-radius: 50%; display: inline-block; margin-right: 8px; }
        .config-status-dot.green { background: var(--success); }
        .config-status-dot.yellow { background: var(--warning); }
        .mode-badge { display: inline-block; padding: 4px 10px; border-radius: 4px; font-size: 0.75rem; font-weight: 600; margin-left: 12px; }
        .mode-badge.shared { background: rgba(34,197,94,0.2); color: var(--success); }
        .mode-badge.local { background: rgba(234,179,8,0.2); color: var(--warning); }
        
        /* Error Log Panel */
        .error-log-panel { background: var(--bg-input); border-radius: 8px; margin-top: 16px; }
        .error-log-header { display: flex; justify-content: space-between; align-items: center; padding: 12px 16px; border-bottom: 1px solid var(--border); }
        .error-log-list { max-height: 300px; overflow-y: auto; }
        .error-log-item { padding: 12px 16px; border-bottom: 1px solid var(--border); display: flex; gap: 12px; }
        .error-log-item:last-child { border-bottom: none; }
        .error-log-item.resolved { opacity: 0.6; }
        .error-severity { padding: 2px 6px; border-radius: 4px; font-size: 0.7rem; font-weight: 600; }
        .error-severity.warning { background: rgba(234,179,8,0.2); color: var(--warning); }
        .error-severity.error { background: rgba(239,68,68,0.2); color: var(--error); }
        .error-severity.critical { background: var(--error); color: white; }

        /* Toggle Switch Styles */
        .toggle-switch { position: relative; display: inline-block; width: 50px; height: 26px; }
        .toggle-switch input { opacity: 0; width: 0; height: 0; }
        .toggle-slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #4a5568; border-radius: 26px; transition: 0.3s; }
        .toggle-slider:before { position: absolute; content: ""; height: 20px; width: 20px; left: 3px; bottom: 3px; background-color: white; border-radius: 50%; transition: 0.3s; }
        .toggle-switch input:checked + .toggle-slider { background-color: var(--success); }
        .toggle-switch input:checked + .toggle-slider:before { transform: translateX(24px); }
        .toggle-switch input:disabled + .toggle-slider { opacity: 0.5; cursor: not-allowed; }
        
        /* Channel Toggle Card */
        .channel-toggle-row { display: flex; align-items: center; justify-content: space-between; padding: 16px; background: var(--bg-input); border-radius: 8px; margin-bottom: 12px; }
        .channel-toggle-info { display: flex; align-items: center; gap: 12px; }
        .channel-toggle-icon { width: 40px; height: 40px; border-radius: 8px; display: flex; align-items: center; justify-content: center; font-size: 1.2rem; }
        .channel-toggle-icon.etsy { background: var(--etsy-bg); color: var(--etsy); }
        .channel-toggle-icon.wix { background: var(--wix-bg); color: var(--wix); }
        .channel-toggle-icon.wayfair { background: var(--wayfair-bg); color: var(--wayfair); }
        .channel-toggle-icon.background { background: rgba(139,92,246,0.15); color: #8b5cf6; }
        .channel-toggle-details { }
        .channel-toggle-name { font-weight: 600; margin-bottom: 2px; }
        .channel-toggle-desc { font-size: 0.8rem; color: var(--text-dim); }
        .channel-toggle-status { font-size: 0.75rem; padding: 2px 8px; border-radius: 4px; margin-left: 8px; }
        .channel-toggle-status.enabled { background: var(--success-bg); color: var(--success); }
        .channel-toggle-status.disabled { background: rgba(239,68,68,0.15); color: var(--error); }
    </style>
</head>
<body>
    <header class="header">
        <div class="header-left">
            <div class="logo">
                <div class="logo-icon">üîÑ</div>
                <span>CCD Sync Hub v3.2.2 ‚Ä¢ Build: 2026-01-30 ‚Ä¢ Improved Persistence</span>
            </div>
            <nav class="header-nav">
                <button class="nav-btn active" data-view="queue" onclick="switchView('queue')">üìã Queue</button>
                <button class="nav-btn" data-view="orders" onclick="switchView('orders')">üõí Orders</button>
                <button class="nav-btn" data-view="activity" onclick="switchView('activity')">üìä Activity</button>
                <button class="nav-btn" data-view="notifications" onclick="switchView('notifications')">üîî Notifications</button>
                <button class="nav-btn" data-view="settings" onclick="switchView('settings')">‚öôÔ∏è Settings</button>
            </nav>
        </div>
        <div class="header-right">
            <span id="autoSyncStatus" style="font-size: 0.85rem; color: var(--text-dim);"></span>
            <button class="btn btn-secondary btn-sm" onclick="refreshData()">üîÑ Refresh</button>
            <button class="btn btn-secondary btn-sm" onclick="window.open('CCD-CHANNEL-MANAGER.html', '_blank')">üì¶ Channel Manager</button>
        </div>
    </header>

    <div class="container">
        <!-- GLOBAL ERROR PANEL -->
        <div id="globalErrorPanel" class="error-panel">
            <div class="error-panel-header">
                <span class="error-panel-title">‚ö†Ô∏è Errors Detected</span>
                <button class="btn btn-sm btn-secondary" onclick="clearErrors()">Clear</button>
            </div>
            <div id="errorPanelContent" class="error-panel-content"></div>
        </div>

        <!-- MASTER JSON CONNECTION BANNER - Shows when not connected -->
        <div id="masterJsonConnectionBanner" style="background: linear-gradient(135deg, rgba(59,130,246,0.15), rgba(139,92,246,0.15)); border: 2px solid var(--info); border-radius: 12px; padding: 20px; margin-bottom: 24px; display: block;">
            <div style="display: flex; align-items: center; gap: 16px; flex-wrap: wrap;">
                <span style="font-size: 2.5rem;">üìÅ</span>
                <div style="flex: 1; min-width: 200px;">
                    <div style="font-weight: 700; font-size: 1.1rem; color: var(--text); margin-bottom: 4px;">Connect Your Master Inventory File</div>
                    <div style="font-size: 0.9rem; color: var(--text-dim);">Select your <code>ccd-inventory-MASTER.json</code> file to enable order processing and inventory sync.</div>
                </div>
                <button class="btn btn-primary" onclick="selectMasterJsonFile()" style="white-space: nowrap;">
                    üìÇ Select Master JSON File
                </button>
            </div>
        </div>

        <!-- MASTER JSON RECONNECT BANNER - Shows when permission needed -->
        <div id="masterJsonReconnectBanner" style="background: rgba(234,179,8,0.15); border: 2px solid var(--warning); border-radius: 12px; padding: 20px; margin-bottom: 24px; display: none;">
            <div style="display: flex; align-items: center; gap: 16px; flex-wrap: wrap;">
                <span style="font-size: 2.5rem;">üîÑ</span>
                <div style="flex: 1; min-width: 200px;">
                    <div style="font-weight: 700; font-size: 1.1rem; color: var(--text); margin-bottom: 4px;">Reconnect to Master JSON</div>
                    <div style="font-size: 0.9rem; color: var(--text-dim);">Click to restore connection to <strong id="reconnectFileName">your file</strong></div>
                </div>
                <button class="btn btn-primary" onclick="reconnectMasterJson()" style="white-space: nowrap;">
                    üîó Reconnect Now
                </button>
            </div>
        </div>

        <!-- QUEUE VIEW -->
        <div id="queueView" class="view active">
            <!-- MANUAL PULL SECTION -->
            <div class="card" style="margin-bottom: 24px;">
                <div class="card-header">
                    <span class="card-title">üì• Pull Orders from Channels</span>
                </div>
                <div style="display: flex; gap: 16px; align-items: flex-end; flex-wrap: wrap;">
                    <div style="flex: 1; min-width: 200px;">
                        <label class="form-label">Time Range</label>
                        <select class="form-input" id="pullTimeRange">
                            <option value="1">Last 1 Hour</option>
                            <option value="4">Last 4 Hours</option>
                            <option value="24" selected>Last 24 Hours</option>
                            <option value="48">Last 48 Hours</option>
                            <option value="168">Last 7 Days</option>
                            <option value="custom">Custom Date Range</option>
                        </select>
                    </div>
                    <div id="customDateRange" style="display: none; flex: 2; min-width: 300px;">
                        <label class="form-label">Custom Range</label>
                        <div style="display: flex; gap: 8px;">
                            <input type="datetime-local" class="form-input" id="pullStartDate">
                            <span style="align-self: center;">to</span>
                            <input type="datetime-local" class="form-input" id="pullEndDate">
                        </div>
                    </div>
                    <div style="display: flex; gap: 8px;">
                        <button class="btn btn-primary" onclick="pullOrdersFromChannels()">
                            üì• Pull Orders Now
                        </button>
                    </div>
                </div>
                <div style="display: flex; gap: 12px; margin-top: 16px;">
                    <label class="form-checkbox">
                        <input type="checkbox" id="pullEtsy" checked>
                        <span style="color: var(--etsy);">Etsy</span>
                    </label>
                    <label class="form-checkbox">
                        <input type="checkbox" id="pullWix" checked>
                        <span style="color: var(--wix);">Wix</span>
                    </label>
                    <label class="form-checkbox">
                        <input type="checkbox" id="pullWayfair" checked>
                        <span style="color: var(--wayfair);">Wayfair</span>
                    </label>
                </div>
                <div id="pullResults" style="margin-top: 16px; display: none;">
                    <div style="padding: 12px; background: var(--bg-input); border-radius: 6px; font-size: 0.9rem;">
                        <div id="pullResultsContent"></div>
                    </div>
                </div>
            </div>

            <!-- AUTO-SYNC SETTINGS - v3.9 -->
            <div class="card" style="margin-bottom: 24px; border: 2px solid var(--info);">
                <div class="card-header">
                    <span class="card-title">‚ö° Auto-Sync Settings</span>
                    <span id="autoSyncStatusBadge" class="mode-badge local" style="background: rgba(239,68,68,0.2); color: var(--error);">DISABLED</span>
                </div>
                <p style="color: var(--text-dim); font-size: 0.85rem; margin-bottom: 16px;">
                    Enable automatic polling and pushing to keep inventory in sync across all channels.
                </p>
                
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 20px;">
                    <!-- Auto-Poll Orders -->
                    <div style="background: var(--bg-input); padding: 16px; border-radius: 8px;">
                        <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 12px;">
                            <label class="form-checkbox" style="margin: 0;">
                                <input type="checkbox" id="autoPollEnabled" onchange="toggleAutoPoll()">
                                <span style="font-weight: 600;">Auto-Poll Orders</span>
                            </label>
                        </div>
                        <p style="font-size: 0.8rem; color: var(--text-dim); margin-bottom: 12px;">
                            Automatically check channels for new orders at regular intervals.
                        </p>
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <label style="font-size: 0.85rem; color: var(--text-dim);">Poll every:</label>
                            <select class="form-input" id="autoPollInterval" style="width: auto; min-width: 140px;" onchange="updateAutoPollInterval()">
                                <option value="5">5 minutes</option>
                                <option value="10">10 minutes</option>
                                <option value="15" selected>15 minutes</option>
                                <option value="30">30 minutes</option>
                                <option value="60">60 minutes</option>
                            </select>
                        </div>
                        <div id="autoPollStatus" style="margin-top: 12px; padding: 8px; background: rgba(0,0,0,0.2); border-radius: 4px; font-size: 0.8rem; display: none;">
                            <span id="autoPollStatusText">Next poll: --</span>
                        </div>
                    </div>
                    
                    <!-- Auto-Push on Change -->
                    <div style="background: var(--bg-input); padding: 16px; border-radius: 8px;">
                        <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 12px;">
                            <label class="form-checkbox" style="margin: 0;">
                                <input type="checkbox" id="autoPushEnabled" onchange="toggleAutoPush()">
                                <span style="font-weight: 600;">Auto-Push on Change</span>
                            </label>
                        </div>
                        <p style="font-size: 0.8rem; color: var(--text-dim); margin-bottom: 12px;">
                            Automatically push inventory updates to channels when changes are detected.
                        </p>
                        <div style="display: flex; flex-direction: column; gap: 8px;">
                            <label class="form-checkbox" style="font-size: 0.85rem;">
                                <input type="checkbox" id="autoPushEtsy" checked>
                                <span style="color: var(--etsy);">Push to Etsy</span>
                            </label>
                            <label class="form-checkbox" style="font-size: 0.85rem;">
                                <input type="checkbox" id="autoPushWix" checked>
                                <span style="color: var(--wix);">Push to Wix</span>
                            </label>
                            <label class="form-checkbox" style="font-size: 0.85rem;">
                                <input type="checkbox" id="autoPushWayfair" checked>
                                <span style="color: var(--wayfair);">Push to Wayfair</span>
                            </label>
                        </div>
                    </div>
                    
                    <!-- Alert Settings -->
                    <div style="background: var(--bg-input); padding: 16px; border-radius: 8px;">
                        <div style="font-weight: 600; margin-bottom: 12px;">üîî Sync Alerts</div>
                        <div style="display: flex; flex-direction: column; gap: 8px;">
                            <label class="form-checkbox" style="font-size: 0.85rem;">
                                <input type="checkbox" id="alertZeroStock" checked onchange="saveAutoSyncSettings()">
                                <span>Zero Stock Alerts</span>
                            </label>
                            <label class="form-checkbox" style="font-size: 0.85rem;">
                                <input type="checkbox" id="alertMismatch" checked onchange="saveAutoSyncSettings()">
                                <span>Inventory Mismatch Alerts</span>
                            </label>
                            <label class="form-checkbox" style="font-size: 0.85rem;">
                                <input type="checkbox" id="alertSyncErrors" checked onchange="saveAutoSyncSettings()">
                                <span>Sync Error Alerts</span>
                            </label>
                        </div>
                    </div>
                </div>
                
                <!-- Auto-Sync Activity Log -->
                <div style="margin-top: 16px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                        <span style="font-weight: 600; font-size: 0.9rem;">üìã Auto-Sync Activity</span>
                        <button class="btn btn-secondary" style="padding: 4px 10px; font-size: 0.75rem;" onclick="clearAutoSyncLog()">Clear Log</button>
                    </div>
                    <div id="autoSyncLog" style="max-height: 150px; overflow-y: auto; background: var(--bg-input); border-radius: 6px; padding: 12px; font-family: 'Monaco', 'Menlo', monospace; font-size: 0.75rem;">
                        <div style="color: var(--text-dim); text-align: center;">Auto-sync log will appear here when enabled.</div>
                    </div>
                </div>
            </div>

            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-card-header">
                        <span class="stat-label">Total in Queue</span>
                        <span class="stat-icon">üìã</span>
                    </div>
                    <div class="stat-value" id="statTotal">0</div>
                    <div class="stat-subtext">operations</div>
                </div>
                <div class="stat-card">
                    <div class="stat-card-header">
                        <span class="stat-label">Pending</span>
                        <span class="stat-icon">‚è≥</span>
                    </div>
                    <div class="stat-value" id="statPending">0</div>
                    <div class="stat-subtext">waiting to process</div>
                </div>
                <div class="stat-card">
                    <div class="stat-card-header">
                        <span class="stat-label">Completed</span>
                        <span class="stat-icon">‚úÖ</span>
                    </div>
                    <div class="stat-value" id="statCompleted">0</div>
                    <div class="stat-subtext">successfully synced</div>
                </div>
                <div class="stat-card">
                    <div class="stat-card-header">
                        <span class="stat-label">Failed</span>
                        <span class="stat-icon">‚ùå</span>
                    </div>
                    <div class="stat-value" id="statFailed">0</div>
                    <div class="stat-subtext">needs attention</div>
                </div>
            </div>

            <div class="card">
                <div class="card-header">
                    <span class="card-title">Sync Queue</span>
                    <div style="display: flex; gap: 8px;">
                        <button class="btn btn-primary" id="processBtn" onclick="processQueue()">‚ñ∂Ô∏è Process Queue</button>
                        <button class="btn btn-secondary" onclick="clearCompletedItems()">üßπ Clear Completed</button>
                        <button class="btn btn-danger" onclick="clearQueue()">üóëÔ∏è Clear All</button>
                    </div>
                </div>
                <div id="queueContainer"></div>
            </div>
        </div>

        <!-- ORDERS VIEW -->
        <div id="ordersView" class="view">
            <!-- Order Stats -->
            <div class="stats-grid" style="margin-bottom: 24px;">
                <div class="stat-card" style="border-left: 3px solid var(--etsy);">
                    <div class="stat-card-header">
                        <span class="stat-label">Etsy Orders</span>
                        <span class="stat-icon">üõí</span>
                    </div>
                    <div class="stat-value" id="etsyOrderCount">0</div>
                    <div class="stat-subtext">pending processing</div>
                </div>
                <div class="stat-card" style="border-left: 3px solid var(--wix);">
                    <div class="stat-card-header">
                        <span class="stat-label">Wix Orders</span>
                        <span class="stat-icon">üåê</span>
                    </div>
                    <div class="stat-value" id="wixOrderCount">0</div>
                    <div class="stat-subtext">pending processing</div>
                </div>
                <div class="stat-card" style="border-left: 3px solid var(--wayfair);">
                    <div class="stat-card-header">
                        <span class="stat-label">Wayfair Orders</span>
                        <span class="stat-icon">üè†</span>
                    </div>
                    <div class="stat-value" id="wayfairOrderCount">0</div>
                    <div class="stat-subtext">pending processing</div>
                </div>
                <div class="stat-card" style="border-left: 3px solid var(--warning);">
                    <div class="stat-card-header">
                        <span class="stat-label">Low Stock Alerts</span>
                        <span class="stat-icon">‚ö†Ô∏è</span>
                    </div>
                    <div class="stat-value" id="lowStockCount">0</div>
                    <div class="stat-subtext">below PAR level</div>
                </div>
            </div>

            <!-- Channel Tabs -->
            <div class="card">
                <div class="card-header" style="border-bottom: 1px solid var(--border);">
                    <div style="display: flex; gap: 4px;">
                        <button class="btn btn-sm" id="ordersTabAll" onclick="switchOrdersTab('all')" style="background: var(--bg-hover);">üì¶ All Orders</button>
                        <button class="btn btn-sm btn-secondary" id="ordersTabEtsy" onclick="switchOrdersTab('etsy')">üõí Etsy</button>
                        <button class="btn btn-sm btn-secondary" id="ordersTabWix" onclick="switchOrdersTab('wix')">üåê Wix</button>
                        <button class="btn btn-sm btn-secondary" id="ordersTabWayfair" onclick="switchOrdersTab('wayfair')">üè† Wayfair</button>
                        <button class="btn btn-sm btn-secondary" id="ordersTabLowStock" onclick="switchOrdersTab('lowstock')">‚ö†Ô∏è Low Stock</button>
                    </div>
                    <div style="display: flex; gap: 8px;">
                        <button class="btn btn-primary" onclick="fetchAllOrders()">üîÑ Fetch Orders</button>
                        <button class="btn btn-success" onclick="processAllOrders()">‚ñ∂Ô∏è Process All</button>
                    </div>
                </div>

                <!-- Orders List -->
                <div id="ordersListContainer" style="max-height: 600px; overflow-y: auto;">
                    <div class="empty-state" id="ordersEmptyState">
                        <div class="empty-state-icon">üì¶</div>
                        <div class="empty-state-title">No Orders Loaded</div>
                        <div>Click "Fetch Orders" to pull recent orders from all channels</div>
                    </div>
                    <div id="ordersList" style="display: none;"></div>
                </div>
            </div>

            <!-- Low Stock Alert Panel -->
            <div class="card" id="lowStockPanel" style="display: none; border: 2px solid var(--warning); margin-top: 24px;">
                <div class="card-header">
                    <span class="card-title">‚ö†Ô∏è Low Stock Alerts (Below PAR Level)</span>
                    <button class="btn btn-secondary" onclick="checkLowStock()">üîÑ Refresh</button>
                </div>
                <div id="lowStockList" style="max-height: 300px; overflow-y: auto;"></div>
            </div>
        </div>

        <!-- ACTIVITY VIEW -->
        <div id="activityView" class="view">
            <div class="card">
                <div class="card-header">
                    <span class="card-title">Activity Log</span>
                    <button class="btn btn-secondary" onclick="clearLog()">üóëÔ∏è Clear Log</button>
                </div>
                <div class="activity-log" id="activityLog"></div>
            </div>
        </div>

        <!-- NOTIFICATIONS VIEW -->
        <div id="notificationsView" class="view">
            <!-- Sync Hub Connection -->
            <div class="card">
                <div class="card-header">
                    <span class="card-title">üîó Sync Hub Connection</span>
                    <button class="btn btn-secondary" onclick="testSyncHubConnection()">üîå Test Connection</button>
                </div>
                <div class="form-group">
                    <label class="form-label">Sync Hub Proxy URL</label>
                    <input type="url" class="form-input" id="syncHubProxyUrl" placeholder="https://script.google.com/macros/s/...">
                </div>
                <div id="syncHubStatus" style="padding: 12px; background: var(--bg-input); border-radius: 6px; font-size: 0.85rem; color: var(--text-dim);">
                    Click "Test Connection" to verify Sync Hub connectivity
                </div>
            </div>

            <!-- Email Settings -->
            <div class="card">
                <div class="card-header">
                    <span class="card-title">üìß Email Settings</span>
                    <div style="display: flex; gap: 8px;">
                        <button class="btn btn-secondary" onclick="loadNotificationSettings()">üì• Load Settings</button>
                        <button class="btn btn-primary" onclick="saveNotificationSettings()">üíæ Save Settings</button>
                    </div>
                </div>
                <div class="form-group">
                    <label class="form-checkbox">
                        <input type="checkbox" id="emailEnabled" checked>
                        <span>Enable Email Notifications</span>
                    </label>
                </div>
                <div class="form-group">
                    <label class="form-label">Email Addresses (comma-separated)</label>
                    <input type="text" class="form-input" id="emailAddresses" placeholder="email1@example.com, email2@example.com">
                </div>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px;">
                    <div class="form-group">
                        <label class="form-label">Digest Frequency</label>
                        <select class="form-input" id="digestFrequency">
                            <option value="realtime">Real-time (Immediate Only)</option>
                            <option value="hourly">Hourly Digest</option>
                            <option value="daily" selected>Daily Digest</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label class="form-label">Digest Hour (0-23)</label>
                        <input type="number" class="form-input" id="digestHour" min="0" max="23" value="8">
                    </div>
                </div>
                <div style="display: flex; gap: 8px; margin-top: 12px;">
                    <button class="btn btn-success" onclick="sendTestEvent()">üì§ Send Test Event</button>
                    <button class="btn btn-secondary" onclick="sendDigestNow()">üìä Send Digest Now</button>
                    <button class="btn btn-secondary" onclick="sendTestEmail()">üìß Send Test Email</button>
                </div>
            </div>

            <!-- Event Notification Preferences - COLLAPSIBLE GROUPS -->
            <div class="card">
                <div class="card-header">
                    <span class="card-title">üîî Event Notification Preferences</span>
                </div>

                <!-- Sales & Inventory Group -->
                <div class="event-group group-sales" id="group-sales">
                    <div class="event-group-header" onclick="toggleGroup('sales')">
                        <div class="event-group-title">
                            <span class="icon">üí∞</span>
                            <span>Sales & Inventory</span>
                            <span class="event-group-badge">2 events</span>
                        </div>
                        <span class="event-group-toggle">‚ñº</span>
                    </div>
                    <div class="event-group-content">
                        <div class="event-row">
                            <div class="event-info">
                                <div class="name">üõí Sale Recorded</div>
                                <div class="desc">New sale from Etsy, Wix, or Wayfair</div>
                            </div>
                            <select class="event-select" id="notify_order.created">
                                <option value="immediate" selected>üì± Immediate</option>
                                <option value="digest">üìã Digest</option>
                                <option value="none">üîá None</option>
                            </select>
                        </div>
                        <div class="event-row">
                            <div class="event-info">
                                <div class="name">üö´ Item Sold Out</div>
                                <div class="desc">Item qty reached 0, all channels set to 0</div>
                            </div>
                            <select class="event-select" id="notify_inventory.soldout">
                                <option value="immediate" selected>üì± Immediate</option>
                                <option value="digest">üìã Digest</option>
                                <option value="none">üîá None</option>
                            </select>
                        </div>
                    </div>
                </div>

                <!-- Stock Alerts Group -->
                <div class="event-group group-stock" id="group-stock">
                    <div class="event-group-header" onclick="toggleGroup('stock')">
                        <div class="event-group-title">
                            <span class="icon">‚ö†Ô∏è</span>
                            <span>Stock Alerts</span>
                            <span class="event-group-badge">3 events</span>
                        </div>
                        <span class="event-group-toggle">‚ñº</span>
                    </div>
                    <div class="event-group-content">
                        <div class="event-row">
                            <div class="event-info">
                                <div class="name">üè≠ PAR Reorder Alert</div>
                                <div class="desc">Warehouse stock below reorder point</div>
                            </div>
                            <select class="event-select" id="notify_par.reorder">
                                <option value="immediate" selected>üì± Immediate</option>
                                <option value="digest">üìã Digest</option>
                                <option value="none">üîá None</option>
                            </select>
                        </div>
                        <div class="event-row">
                            <div class="event-info">
                                <div class="name">üåê Channel PAR Alert</div>
                                <div class="desc">Can't maintain Wix/Etsy display qty</div>
                            </div>
                            <select class="event-select" id="notify_par.channel_low">
                                <option value="immediate" selected>üì± Immediate</option>
                                <option value="digest">üìã Digest</option>
                                <option value="none">üîá None</option>
                            </select>
                        </div>
                        <div class="event-row">
                            <div class="event-info">
                                <div class="name">üìâ Low Stock Warning</div>
                                <div class="desc">Item below threshold</div>
                            </div>
                            <select class="event-select" id="notify_low.stock">
                                <option value="immediate">üì± Immediate</option>
                                <option value="digest" selected>üìã Digest</option>
                                <option value="none">üîá None</option>
                            </select>
                        </div>
                    </div>
                </div>

                <!-- Wayfair Group -->
                <div class="event-group group-wayfair" id="group-wayfair">
                    <div class="event-group-header" onclick="toggleGroup('wayfair')">
                        <div class="event-group-title">
                            <span class="icon">üè™</span>
                            <span>Wayfair</span>
                            <span class="event-group-badge">2 events</span>
                        </div>
                        <span class="event-group-toggle">‚ñº</span>
                    </div>
                    <div class="event-group-content">
                        <div class="event-row">
                            <div class="event-info">
                                <div class="name">üè™ New Wayfair Order</div>
                                <div class="desc">New PO detected from email parser</div>
                            </div>
                            <select class="event-select" id="notify_wayfair.order">
                                <option value="immediate" selected>üì± Immediate</option>
                                <option value="digest">üìã Digest</option>
                                <option value="none">üîá None</option>
                            </select>
                        </div>
                        <div class="event-row">
                            <div class="event-info">
                                <div class="name">üì• Wayfair Sync Complete</div>
                                <div class="desc">Orders synced to inventory</div>
                            </div>
                            <select class="event-select" id="notify_wayfair.sync">
                                <option value="immediate">üì± Immediate</option>
                                <option value="digest" selected>üìã Digest</option>
                                <option value="none">üîá None</option>
                            </select>
                        </div>
                    </div>
                </div>

                <!-- Sync & System Group -->
                <div class="event-group group-sync collapsed" id="group-sync">
                    <div class="event-group-header" onclick="toggleGroup('sync')">
                        <div class="event-group-title">
                            <span class="icon">üîÑ</span>
                            <span>Sync & System</span>
                            <span class="event-group-badge">4 events</span>
                        </div>
                        <span class="event-group-toggle">‚ñº</span>
                    </div>
                    <div class="event-group-content">
                        <div class="event-row">
                            <div class="event-info">
                                <div class="name">üîÑ Channel Sync</div>
                                <div class="desc">Inventory synced between channels</div>
                            </div>
                            <select class="event-select" id="notify_channel.sync">
                                <option value="immediate">üì± Immediate</option>
                                <option value="digest" selected>üìã Digest</option>
                                <option value="none">üîá None</option>
                            </select>
                        </div>
                        <div class="event-row">
                            <div class="event-info">
                                <div class="name">‚ö° Sync Conflict</div>
                                <div class="desc">Mobile/desktop have conflicting changes</div>
                            </div>
                            <select class="event-select" id="notify_sync.conflict">
                                <option value="immediate" selected>üì± Immediate</option>
                                <option value="digest">üìã Digest</option>
                                <option value="none">üîá None</option>
                            </select>
                        </div>
                        <div class="event-row">
                            <div class="event-info">
                                <div class="name">‚úÖ Sync Completed</div>
                                <div class="desc">Successful sync operation</div>
                            </div>
                            <select class="event-select" id="notify_sync.completed">
                                <option value="immediate">üì± Immediate</option>
                                <option value="digest" selected>üìã Digest</option>
                                <option value="none">üîá None</option>
                            </select>
                        </div>
                        <div class="event-row">
                            <div class="event-info">
                                <div class="name">üß™ Test Events</div>
                                <div class="desc">Test/debug events</div>
                            </div>
                            <select class="event-select" id="notify_test">
                                <option value="immediate" selected>üì± Immediate</option>
                                <option value="digest">üìã Digest</option>
                                <option value="none">üîá None</option>
                            </select>
                        </div>
                    </div>
                </div>

                <!-- Errors & Failures Group -->
                <div class="event-group group-errors" id="group-errors">
                    <div class="event-group-header" onclick="toggleGroup('errors')">
                        <div class="event-group-title">
                            <span class="icon">üö®</span>
                            <span>Errors & Failures</span>
                            <span class="event-group-badge">4 events</span>
                        </div>
                        <span class="event-group-toggle">‚ñº</span>
                    </div>
                    <div class="event-group-content">
                        <div class="event-row">
                            <div class="event-info">
                                <div class="name">üí• Critical Error</div>
                                <div class="desc">System-level critical failure</div>
                            </div>
                            <select class="event-select" id="notify_critical.error">
                                <option value="immediate" selected>üì± Immediate</option>
                                <option value="digest">üìã Digest</option>
                                <option value="none">üîá None</option>
                            </select>
                        </div>
                        <div class="event-row">
                            <div class="event-info">
                                <div class="name">üîå Connection Error</div>
                                <div class="desc">API or service connection failed</div>
                            </div>
                            <select class="event-select" id="notify_connection.error">
                                <option value="immediate" selected>üì± Immediate</option>
                                <option value="digest">üìã Digest</option>
                                <option value="none">üîá None</option>
                            </select>
                        </div>
                        <div class="event-row">
                            <div class="event-info">
                                <div class="name">üö® Sync Failed</div>
                                <div class="desc">Sync operation failed</div>
                            </div>
                            <select class="event-select" id="notify_sync.failed">
                                <option value="immediate" selected>üì± Immediate</option>
                                <option value="digest">üìã Digest</option>
                                <option value="none">üîá None</option>
                            </select>
                        </div>
                        <div class="event-row">
                            <div class="event-info">
                                <div class="name">üíæ Backup Failed</div>
                                <div class="desc">Automated backup failed</div>
                            </div>
                            <select class="event-select" id="notify_backup.failed">
                                <option value="immediate" selected>üì± Immediate</option>
                                <option value="digest">üìã Digest</option>
                                <option value="none">üîá None</option>
                            </select>
                        </div>
                    </div>
                </div>

                <!-- Shipping Group -->
                <div class="event-group group-shipping collapsed" id="group-shipping">
                    <div class="event-group-header" onclick="toggleGroup('shipping')">
                        <div class="event-group-title">
                            <span class="icon">üì¶</span>
                            <span>Shipping</span>
                            <span class="event-group-badge">3 events</span>
                        </div>
                        <span class="event-group-toggle">‚ñº</span>
                    </div>
                    <div class="event-group-content">
                        <div class="event-row">
                            <div class="event-info">
                                <div class="name">‚úÖ Delivery Confirmed</div>
                                <div class="desc">Package delivered</div>
                            </div>
                            <select class="event-select" id="notify_delivery.confirmed">
                                <option value="immediate">üì± Immediate</option>
                                <option value="digest" selected>üìã Digest</option>
                                <option value="none">üîá None</option>
                            </select>
                        </div>
                        <div class="event-row">
                            <div class="event-info">
                                <div class="name">üìç Tracking Updated</div>
                                <div class="desc">Package scan events</div>
                            </div>
                            <select class="event-select" id="notify_tracking.updated">
                                <option value="immediate">üì± Immediate</option>
                                <option value="digest">üìã Digest</option>
                                <option value="none" selected>üîá None</option>
                            </select>
                        </div>
                        <div class="event-row">
                            <div class="event-info">
                                <div class="name">üè∑Ô∏è Label Created</div>
                                <div class="desc">Shipping label purchased</div>
                            </div>
                            <select class="event-select" id="notify_label.created">
                                <option value="immediate">üì± Immediate</option>
                                <option value="digest" selected>üìã Digest</option>
                                <option value="none">üîá None</option>
                            </select>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Recent Events from Sync Hub -->
            <div class="card">
                <div class="card-header">
                    <span class="card-title">üìã Recent Events (from Sync Hub)</span>
                    <div style="display: flex; gap: 8px;">
                        <button class="btn btn-secondary" onclick="viewSyncHubEvents()">üîÑ Refresh</button>
                        <button class="btn btn-danger" onclick="clearSyncHubEvents()">üóëÔ∏è Clear Events</button>
                    </div>
                </div>
                <div class="activity-log" id="syncHubEventLog" style="max-height: 300px;">
                    <div class="empty-state" style="padding: 30px;">
                        <div class="empty-state-icon">üìã</div>
                        <div class="empty-state-title">No Events Loaded</div>
                        <div>Click "Refresh" to load events from Sync Hub</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- SETTINGS VIEW -->
        <div id="settingsView" class="view">
            <!-- SHARED CONFIGURATION - NEW SECTION -->
            <div class="card" style="border: 2px solid #8b5cf6;">
                <div class="card-header">
                    <span class="card-title">üîó Shared Configuration (Multi-PC Sync)</span>
                    <span id="configModeBadge" class="mode-badge local">LOCAL MODE</span>
                </div>
                <p style="color: var(--text-dim); font-size: 0.85rem; margin-bottom: 16px;">
                    Connect to a shared config file to sync settings, logs, and activity across all PCs.
                    Store this file in the same OneDrive folder as your Master inventory file.
                </p>
                
                <div id="configStatus" class="config-status-banner disconnected">
                    <span class="config-status-dot yellow"></span>
                    <strong>Local Mode</strong> - Using browser storage only
                    <br><small style="color: var(--text-dim);">Settings and logs are not shared with other PCs</small>
                </div>
                
                <div style="display: flex; gap: 12px; flex-wrap: wrap;">
                    <button class="btn btn-primary" onclick="connectConfigFile()" id="btnConnectConfig">
                        üìÇ Connect Config File
                    </button>
                    <button class="btn btn-secondary" onclick="createConfigFile()" id="btnCreateConfig">
                        ‚ûï Create New Config File
                    </button>
                    <button class="btn btn-danger" onclick="disconnectConfigFile()" id="btnDisconnectConfig" style="display: none;">
                        üîå Disconnect
                    </button>
                </div>
                
                <!-- Error Log Panel -->
                <div id="sharedErrorLogPanel" class="error-log-panel" style="display: none; margin-top: 16px;">
                    <div class="error-log-header">
                        <span style="font-weight: 600;">üìã Recent Errors</span>
                        <button class="btn btn-sm btn-secondary" onclick="refreshErrorLog()">üîÑ Refresh</button>
                    </div>
                    <div id="sharedErrorLogList" class="error-log-list">
                        <!-- Populated dynamically -->
                    </div>
                </div>
            </div>

            <!-- MASTER JSON FILE - CRITICAL SECTION -->
            <div class="card" style="border: 2px solid var(--info);">
                <div class="card-header">
                    <span class="card-title">üìÅ Master JSON File (Source of Truth)</span>
                    <div style="display: flex; gap: 8px;">
                        <button class="btn btn-primary" onclick="selectMasterJsonFile()">üìÇ Select File</button>
                        <button class="btn btn-secondary" onclick="loadMasterJson()">üîÑ Reload</button>
                    </div>
                </div>
                <p style="color: var(--text-dim); font-size: 0.85rem; margin-bottom: 16px;">
                    Connect to your Master Inventory JSON file on OneDrive. This file serves as the single source of truth for all inventory data.
                </p>
                
                <div id="masterJsonStatus" style="padding: 16px; background: var(--bg-input); border-radius: 8px; margin-bottom: 16px;">
                    <div style="display: flex; align-items: center; gap: 12px;">
                        <span id="masterJsonIcon" style="font-size: 2rem;">üìÑ</span>
                        <div style="flex: 1;">
                            <div id="masterJsonFileName" style="font-weight: 600; color: var(--text);">No file selected</div>
                            <div id="masterJsonDetails" style="font-size: 0.85rem; color: var(--text-dim);">Click "Select File" to connect to your master inventory</div>
                        </div>
                        <span id="masterJsonConnectionDot" class="connection-dot disconnected"></span>
                    </div>
                </div>

                <div id="masterJsonStats" style="display: none; margin-bottom: 16px;">
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 12px;">
                        <div style="padding: 12px; background: var(--bg-input); border-radius: 6px; text-align: center;">
                            <div style="font-size: 1.5rem; font-weight: 700; color: var(--info);" id="masterJsonProductCount">0</div>
                            <div style="font-size: 0.8rem; color: var(--text-dim);">Products</div>
                        </div>
                        <div style="padding: 12px; background: var(--bg-input); border-radius: 6px; text-align: center;">
                            <div style="font-size: 1.5rem; font-weight: 700; color: var(--etsy);" id="masterJsonEtsyLinked">0</div>
                            <div style="font-size: 0.8rem; color: var(--text-dim);">Etsy Linked</div>
                        </div>
                        <div style="padding: 12px; background: var(--bg-input); border-radius: 6px; text-align: center;">
                            <div style="font-size: 1.5rem; font-weight: 700; color: var(--wix);" id="masterJsonWixLinked">0</div>
                            <div style="font-size: 0.8rem; color: var(--text-dim);">Wix Linked</div>
                        </div>
                        <div style="padding: 12px; background: var(--bg-input); border-radius: 6px; text-align: center;">
                            <div style="font-size: 1.5rem; font-weight: 700; color: var(--wayfair);" id="masterJsonWayfairLinked">0</div>
                            <div style="font-size: 0.8rem; color: var(--text-dim);">Wayfair Linked</div>
                        </div>
                    </div>
                </div>

                <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                    <button class="btn btn-secondary" onclick="viewMasterJsonProducts()" id="btnViewProducts" disabled>üëÅÔ∏è View Products</button>
                    <button class="btn btn-secondary" onclick="exportMasterJson()" id="btnExportJson" disabled>üì§ Export Backup</button>
                    <button class="btn btn-secondary" onclick="validateMasterJson()" id="btnValidateJson" disabled>‚úÖ Validate Data</button>
                </div>
            </div>

            <!-- SYNC DATA FILE - v3.9 -->
            <div class="card" style="border: 2px solid #22c55e;">
                <div class="card-header">
                    <span class="card-title">üìä Sync Data File (Orders)</span>
                    <div style="display: flex; gap: 8px;">
                        <button class="btn btn-primary" onclick="connectSyncDataFile()">üìÇ Select File</button>
                        <button class="btn btn-secondary" onclick="createSyncDataFile()">‚ûï Create New</button>
                    </div>
                </div>
                <p style="color: var(--text-dim); font-size: 0.85rem; margin-bottom: 16px;">
                    Connect to ccd-sync-data.json to store orders from all channels. This file is read by Channel Manager, Financial Dashboard, and Inventory System.
                </p>
                
                <div id="syncDataStatus" style="padding: 16px; background: var(--bg-input); border-radius: 8px; margin-bottom: 16px;">
                    <div style="display: flex; align-items: center; gap: 12px;">
                        <span style="font-size: 2rem;">üìä</span>
                        <div style="flex: 1;">
                            <div id="syncDataFileName" style="font-weight: 600; color: var(--text);">No file selected</div>
                            <div id="syncDataDetails" style="font-size: 0.85rem; color: var(--text-dim);">Orders will be saved to this file after each sync</div>
                        </div>
                        <div id="syncDataFileStatus" class="connection-status">
                            <span class="connection-dot disconnected"></span>
                            <span class="status-text">Not Connected</span>
                        </div>
                    </div>
                </div>

                <div id="syncDataStats" style="display: none; margin-bottom: 16px;">
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 12px;">
                        <div style="padding: 12px; background: var(--bg-input); border-radius: 6px; text-align: center;">
                            <div style="font-size: 1.5rem; font-weight: 700; color: var(--etsy);" id="syncDataEtsyOrders">0</div>
                            <div style="font-size: 0.8rem; color: var(--text-dim);">Etsy Orders</div>
                        </div>
                        <div style="padding: 12px; background: var(--bg-input); border-radius: 6px; text-align: center;">
                            <div style="font-size: 1.5rem; font-weight: 700; color: var(--wix);" id="syncDataWixOrders">0</div>
                            <div style="font-size: 0.8rem; color: var(--text-dim);">Wix Orders</div>
                        </div>
                        <div style="padding: 12px; background: var(--bg-input); border-radius: 6px; text-align: center;">
                            <div style="font-size: 1.5rem; font-weight: 700; color: var(--wayfair);" id="syncDataWayfairOrders">0</div>
                            <div style="font-size: 0.8rem; color: var(--text-dim);">Wayfair Orders</div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="card">
                <div class="card-header">
                    <span class="card-title">Connection Status</span>
                    <button class="btn btn-secondary" onclick="testAllConnections()">üîå Test All</button>
                </div>
                <div class="connection-grid">
                    <div class="connection-card">
                        <div class="connection-icon" style="background: rgba(102,126,234,0.15); color: #667eea;">üìÅ</div>
                        <div class="connection-info">
                            <div class="connection-name">Master JSON</div>
                            <div class="connection-status" id="masterJsonConnStatus"><span class="connection-dot disconnected"></span>Not connected</div>
                        </div>
                        <button class="btn btn-sm btn-secondary" onclick="selectMasterJsonFile()">Connect</button>
                    </div>
                    <div class="connection-card">
                        <div class="connection-icon etsy">üõí</div>
                        <div class="connection-info">
                            <div class="connection-name">Etsy</div>
                            <div class="connection-status" id="etsyStatus"><span class="connection-dot disconnected"></span>Not tested</div>
                        </div>
                        <button class="btn btn-sm btn-secondary" onclick="testEtsy()">Test</button>
                    </div>
                    <div class="connection-card">
                        <div class="connection-icon wix">üåê</div>
                        <div class="connection-info">
                            <div class="connection-name">Wix</div>
                            <div class="connection-status" id="wixStatus"><span class="connection-dot disconnected"></span>Not tested</div>
                        </div>
                        <button class="btn btn-sm btn-secondary" onclick="testWix()">Test</button>
                    </div>
                    <div class="connection-card">
                        <div class="connection-icon wayfair">üè†</div>
                        <div class="connection-info">
                            <div class="connection-name">Wayfair</div>
                            <div class="connection-status" id="wayfairStatus"><span class="connection-dot disconnected"></span>Not tested</div>
                        </div>
                        <button class="btn btn-sm btn-secondary" onclick="testWayfair()">Test</button>
                    </div>
                    <div class="connection-card">
                        <div class="connection-icon shippo">üì¶</div>
                        <div class="connection-info">
                            <div class="connection-name">Shippo</div>
                            <div class="connection-status" id="shippoStatus"><span class="connection-dot disconnected"></span>Not tested</div>
                        </div>
                        <button class="btn btn-sm btn-secondary" onclick="testShippo()">Test</button>
                    </div>
                    <div class="connection-card">
                        <div class="connection-icon" style="background: rgba(102,126,234,0.15); color: #667eea;">üîî</div>
                        <div class="connection-info">
                            <div class="connection-name">Sync Hub</div>
                            <div class="connection-status" id="syncHubConnStatus"><span class="connection-dot disconnected"></span>Not tested</div>
                        </div>
                        <button class="btn btn-sm btn-secondary" onclick="testSyncHubFromSettings()">Test</button>
                    </div>
                </div>
            </div>

            <!-- CHANNEL SYNC CONTROLS - NEW SECTION -->
            <div class="card" style="border: 2px solid var(--success);">
                <div class="card-header">
                    <span class="card-title">üéõÔ∏è Channel Sync Controls</span>
                    <span style="font-size: 0.8rem; color: var(--text-dim);">Enable/disable sync per channel</span>
                </div>
                <p style="color: var(--text-dim); font-size: 0.85rem; margin-bottom: 16px;">
                    Toggle channels on/off to control which channels are included in order pulls and inventory sync.
                    Disabled channels will be skipped during sync operations.
                </p>
                
                <!-- Etsy Toggle -->
                <div class="channel-toggle-row">
                    <div class="channel-toggle-info">
                        <div class="channel-toggle-icon etsy">üõí</div>
                        <div class="channel-toggle-details">
                            <div class="channel-toggle-name">Etsy
                                <span id="etsySyncStatus" class="channel-toggle-status enabled">ENABLED</span>
                            </div>
                            <div class="channel-toggle-desc">CountryCharmDecorUS store orders and inventory</div>
                        </div>
                    </div>
                    <label class="toggle-switch">
                        <input type="checkbox" id="enableEtsySync" checked onchange="updateChannelToggleStatus('etsy')">
                        <span class="toggle-slider"></span>
                    </label>
                </div>
                
                <!-- Wix Toggle -->
                <div class="channel-toggle-row">
                    <div class="channel-toggle-info">
                        <div class="channel-toggle-icon wix">üåê</div>
                        <div class="channel-toggle-details">
                            <div class="channel-toggle-name">Wix
                                <span id="wixSyncStatus" class="channel-toggle-status enabled">ENABLED</span>
                            </div>
                            <div class="channel-toggle-desc">Country Charm Decor website orders and inventory</div>
                        </div>
                    </div>
                    <label class="toggle-switch">
                        <input type="checkbox" id="enableWixSync" checked onchange="updateChannelToggleStatus('wix')">
                        <span class="toggle-slider"></span>
                    </label>
                </div>
                
                <!-- Wayfair Toggle -->
                <div class="channel-toggle-row">
                    <div class="channel-toggle-info">
                        <div class="channel-toggle-icon wayfair">üè†</div>
                        <div class="channel-toggle-details">
                            <div class="channel-toggle-name">Wayfair
                                <span id="wayfairSyncStatus" class="channel-toggle-status enabled">ENABLED</span>
                            </div>
                            <div class="channel-toggle-desc">Wayfair marketplace orders and inventory</div>
                        </div>
                    </div>
                    <label class="toggle-switch">
                        <input type="checkbox" id="enableWayfairSync" checked onchange="updateChannelToggleStatus('wayfair')">
                        <span class="toggle-slider"></span>
                    </label>
                </div>
                
                <!-- Background Sync Service Note -->
                <div style="margin-top: 16px; padding: 12px; background: rgba(139,92,246,0.1); border: 1px solid rgba(139,92,246,0.3); border-radius: 8px;">
                    <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
                        <span style="font-size: 1.2rem;">‚òÅÔ∏è</span>
                        <strong style="color: #8b5cf6;">Background Sync Service</strong>
                    </div>
                    <p style="font-size: 0.85rem; color: var(--text-dim); margin: 0;">
                        These toggles control the Sync Hub order pulls. The Background Sync Service (Google Apps Script) 
                        runs independently and has its own channel controls in the GAS Config.gs file.
                    </p>
                </div>
            </div>

            <div class="card">
                <div class="card-header">
                    <span class="card-title">Proxy Configuration</span>
                </div>
                <div class="form-group">
                    <label class="form-label">CCD API Key (Wix/Wayfair/Shippo)</label>
                    <input type="text" class="form-input" id="ccdApiKey" placeholder="ccd_...">
                </div>
                <div class="form-group">
                    <label class="form-label">Etsy API Key (if different)</label>
                    <input type="text" class="form-input" id="etsyApiKey" placeholder="Leave blank to use CCD API Key above">
                </div>
                <div class="form-group">
                    <label class="form-label">Etsy Proxy URL</label>
                    <input type="url" class="form-input" id="etsyProxyUrl" placeholder="https://script.google.com/...">
                </div>
                <div class="form-group">
                    <label class="form-label">Wix Proxy URL</label>
                    <input type="url" class="form-input" id="wixProxyUrl" placeholder="https://script.google.com/...">
                </div>
                <div class="form-group">
                    <label class="form-label">Wayfair Proxy URL</label>
                    <input type="url" class="form-input" id="wayfairProxyUrl" placeholder="https://script.google.com/...">
                </div>
                <div class="form-group">
                    <label class="form-label">Shippo Proxy URL</label>
                    <input type="url" class="form-input" id="shippoProxyUrl" placeholder="https://script.google.com/...">
                </div>
                <div class="form-group">
                    <label class="form-label">Sync Hub Proxy URL (Notifications)</label>
                    <input type="url" class="form-input" id="syncHubProxyUrlSettings" placeholder="https://script.google.com/...">
                </div>
                <div class="form-group">
                    <label class="form-checkbox">
                        <input type="checkbox" id="autoProcessEnabled">
                        <span>Enable auto-processing (every 5 minutes)</span>
                    </label>
                </div>
                <div class="form-group">
                    <label class="form-checkbox">
                        <input type="checkbox" id="retryFailedEnabled" checked>
                        <span>Auto-retry failed items (max 3 attempts)</span>
                    </label>
                </div>
                <div style="display: flex; gap: 12px;">
                    <button class="btn btn-primary" onclick="saveSettings()">üíæ Save Settings</button>
                    <button class="btn btn-secondary" onclick="resetSettings()">üîÑ Reset</button>
                </div>
            </div>
        </div>
    </div>

    <div class="toast-container" id="toastContainer"></div>

    <script>
    // Fallback logActivity function (will be replaced by real one later)
    window.logActivity = window.logActivity || function() { console.log('[logActivity not yet initialized]', arguments); };
    
    // =============================================
    // GLOBAL ERROR HANDLING
    // =============================================
    const errorLog = [];
    
    window.onerror = function(message, source, lineno, colno, error) {
        const errorInfo = `${message} at line ${lineno}`;
        console.error('[Global Error]', errorInfo, error);
        logError(errorInfo);
        return false;
    };
    
    window.addEventListener('unhandledrejection', function(event) {
        const errorInfo = `Unhandled Promise: ${event.reason}`;
        console.error('[Unhandled Rejection]', event.reason);
        logError(errorInfo);
    });
    
    function logError(message) {
        const timestamp = new Date().toLocaleTimeString();
        errorLog.push({ timestamp, message });
        if (errorLog.length > 50) errorLog.shift();
        updateErrorPanel();
        
        // Also add to activity log if available
        if (typeof addLog === 'function') {
            addLog(`Error: ${message}`, 'error');
        }
        
        // Send critical error notification for severe errors
        const criticalKeywords = ['failed', 'crash', 'fatal', 'critical', 'corruption', 'lost'];
        const isCritical = criticalKeywords.some(kw => message.toLowerCase().includes(kw));
        
        if (isCritical) {
            sendEventNotification(
                'critical.error',
                `Critical error: ${message}`,
                { 
                    error: message, 
                    timestamp: new Date().toISOString(),
                    errorCount: errorLog.length
                }
            );
        }
    }
    
    function updateErrorPanel() {
        const panel = document.getElementById('globalErrorPanel');
        const content = document.getElementById('errorPanelContent');
        
        if (!panel || !content) return;
        
        if (errorLog.length === 0) {
            panel.classList.remove('visible');
            return;
        }
        
        panel.classList.add('visible');
        content.innerHTML = errorLog.slice(-10).reverse().map(e => 
            `<div class="error-item">[${e.timestamp}] ${e.message}</div>`
        ).join('');
    }
    
    function clearErrors() {
        errorLog.length = 0;
    
    // =============================================
    // ACTIVITY LOG INTEGRATION (v3.9)
    // Centralized logging for all sync events
    // Entries stored in _activityLog array in Master JSON
    // View with CCD-ACTIVITY-LOG.html module
    // =============================================
    
    /**
     * Log an activity entry to the Master JSON _activityLog array
     * @param {string} category - order|sync|inventory|payment|system|error
     * @param {string} action - Specific action (e.g., order_received, cascade_processed)
     * @param {string} channel - wayfair|etsy|wix|system
     * @param {string} summary - Human-readable description
     * @param {object} details - Structured data (orderId, sku, quantities, etc.)
     */
    function logActivity(category, action, channel, summary, details = {}) {
        // Override the fallback function
        window.logActivity = logActivity;
        
        // Only log if we have master data loaded
        if (typeof masterJsonData === 'undefined' || !masterJsonData) {
            console.log(`üìã [Activity] ${category}/${action}: ${summary} (not saved - no master file)`);
            return null;
        }
        
        // Initialize _activityLog if it doesn't exist
        if (!masterJsonData._activityLog) {
            masterJsonData._activityLog = [];
        }
        
        const entry = {
            id: `act_${Date.now()}_${Math.random().toString(36).substr(2, 4)}`,
            timestamp: new Date().toISOString(),
            category: category,
            action: action,
            channel: channel,
            summary: summary,
            details: details,
            device: localStorage.getItem('ccd_hostname') || 'SyncHub',
            user: localStorage.getItem('ccdUsername') || 'Unknown'
        };
        
        // Add to beginning of array (newest first)
        masterJsonData._activityLog.unshift(entry);
        
        // Keep log at reasonable size (last 5000 entries)
        if (masterJsonData._activityLog.length > 5000) {
            masterJsonData._activityLog = masterJsonData._activityLog.slice(0, 5000);
        }
        
        console.log(`üìã [Activity] ${category}/${action}: ${summary}`);
        
        return entry;
    }
    
    // =============================================
    // END ACTIVITY LOG INTEGRATION
    // =============================================
        updateErrorPanel();
        if (typeof toast === 'function') toast('Errors cleared', 'success');
    }

    // =============================================
    // STATE
    // =============================================
    let masterJsonFileHandle = null;
    let masterJsonData = null;
    
    // ============================================================
    // SYNC DATA FILE - Orders from all channels (v3.9)
    // ============================================================
    let syncDataFileHandle = null;
    let syncDataCache = {
        etsy: { orders: [], lastSync: null },
        wix: { orders: [], lastSync: null },
        wayfair: { orders: [], lastSync: null },
        _metadata: { version: 0, lastModified: null, lastModifiedBy: null }
    };
    
    // ============================================================
    // COLLISION DETECTION - Tracking variables
    // ============================================================
    let loadedFileTimestamp = null;     // File's lastModified when loaded
    let loadedMetadataVersion = null;   // _metadata.version when loaded
    
    // ============================================================
    // SHARED CONFIG SYSTEM - Global Variables
    // ============================================================
    let configFileHandle = null;         // Config file handle
    let configData = null;               // Current config data in memory
    let configFileTimestamp = null;      // For collision detection
    let configMetadataVersion = null;    // For change detection
    let isSharedMode = false;            // true = using CONFIG file, false = localStorage
    let configReloadInterval = null;     // Auto-reload interval
    let heartbeatInterval = null;        // Heartbeat write interval
    let configSaveTimeout = null;        // Debounced save timeout
    let autoProcessNextRun = null;       // Next auto-process time
    let lastProcessedOrderId = null;     // Last processed order ID for heartbeat
    
    // ============================================================
    // COLLISION DETECTION FUNCTIONS
    // ============================================================
    
    /**
     * One-time PC name setup for identifying which computer made changes
     */
    function ensureHostnameSet() {
        if (!localStorage.getItem('ccd_hostname')) {
            const name = prompt(
                'Enter a name for this computer (e.g., "Paul PC", "Sync Server", "Dedicated Sync"):\n\n' +
                'This helps identify which computer made changes to the inventory.',
                'Sync Hub PC'
            );
            if (name) {
                localStorage.setItem('ccd_hostname', name.trim());
            }
        }
    }
    
    /**
     * Get app identifier for metadata tracking
     */
    function getAppIdentifier() {
        const appName = 'Sync Hub';
        const hostname = localStorage.getItem('ccd_hostname') || 'Unknown PC';
        return `${appName} (${hostname})`;
    }
    
    /**
     * Check if the master file has been modified since we loaded it
     */
    async function checkForCollision() {
        if (!masterJsonFileHandle) return { collision: false };
        
        try {
            const file = await masterJsonFileHandle.getFile();
            const currentTimestamp = file.lastModified;
            
            // Primary check: file timestamp changed
            if (loadedFileTimestamp && currentTimestamp !== loadedFileTimestamp) {
                // Read current metadata to show who changed it
                const content = await file.text();
                const currentData = JSON.parse(content);
                const meta = currentData._metadata || {};
                
                return {
                    collision: true,
                    ourVersion: loadedMetadataVersion || 0,
                    currentVersion: meta.version || 0,
                    lastModifiedBy: meta.lastModifiedBy || 'Unknown',
                    lastAction: meta.lastAction || 'Unknown action',
                    lastModified: meta.lastModified || 'Unknown time'
                };
            }
            
            return { collision: false };
            
        } catch (error) {
            console.error('Collision check error:', error);
            return { collision: false }; // Fail open - allow save
        }
    }
    
    /**
     * Show collision dialog and return user's choice (for manual operations)
     */
    function showCollisionDialog(collisionInfo) {
        return new Promise((resolve) => {
            // Create modal overlay
            const overlay = document.createElement('div');
            overlay.id = 'collision-modal-overlay';
            overlay.style.cssText = `
                position: fixed; top: 0; left: 0; right: 0; bottom: 0;
                background: rgba(0,0,0,0.5); z-index: 10000;
                display: flex; align-items: center; justify-content: center;
            `;
            
            const modifiedTime = collisionInfo.lastModified !== 'Unknown time' 
                ? new Date(collisionInfo.lastModified).toLocaleString()
                : 'Unknown time';
            
            overlay.innerHTML = `
                <div style="background: var(--bg-card, #141d2f); border-radius: 12px; padding: 24px; max-width: 450px; box-shadow: 0 4px 20px rgba(0,0,0,0.5); border: 1px solid var(--border, #2a3f5f);">
                    <h2 style="margin: 0 0 16px 0; color: #ef4444; display: flex; align-items: center; gap: 10px; font-size: 1.2rem;">
                        ‚ö†Ô∏è File Modified by Another User
                    </h2>
                    <p style="margin: 0 0 12px 0; color: var(--text, #e2e8f0);">
                        The inventory file has been modified since you loaded it.
                    </p>
                    <div style="background: var(--bg-input, #1a2540); padding: 12px; border-radius: 8px; margin-bottom: 16px; font-size: 14px; color: var(--text, #e2e8f0);">
                        <div><strong>Modified by:</strong> ${collisionInfo.lastModifiedBy}</div>
                        <div><strong>Action:</strong> ${collisionInfo.lastAction}</div>
                        <div><strong>Time:</strong> ${modifiedTime}</div>
                    </div>
                    <p style="margin: 0 0 16px 0; color: var(--text-dim, #8892a6); font-size: 14px;">
                        What would you like to do?
                    </p>
                    <div style="display: flex; gap: 12px; flex-wrap: wrap;">
                        <button id="collision-reload" style="flex: 1; padding: 12px; background: #3b82f6; color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600;">
                            üîÑ Reload File
                        </button>
                        <button id="collision-overwrite" style="flex: 1; padding: 12px; background: #ef4444; color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600;">
                            ‚ö†Ô∏è Overwrite Anyway
                        </button>
                    </div>
                    <button id="collision-cancel" style="width: 100%; margin-top: 12px; padding: 10px; background: var(--bg-hover, #1e2d4a); color: var(--text, #e2e8f0); border: 1px solid var(--border, #2a3f5f); border-radius: 8px; cursor: pointer;">
                        Cancel
                    </button>
                </div>
            `;
            
            document.body.appendChild(overlay);
            
            document.getElementById('collision-reload').onclick = () => {
                document.body.removeChild(overlay);
                resolve('reload');
            };
            
            document.getElementById('collision-overwrite').onclick = () => {
                document.body.removeChild(overlay);
                resolve('overwrite');
            };
            
            document.getElementById('collision-cancel').onclick = () => {
                document.body.removeChild(overlay);
                resolve('cancel');
            };
        });
    }
    
    /**
     * Prune change log to keep only last 500 entries and max 30 days
     */
    function pruneChangeLog(data) {
        if (!data._changeLog) return;
        
        const thirtyDaysAgo = new Date();
        thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
        
        // Remove entries older than 30 days
        data._changeLog = data._changeLog.filter(entry => 
            new Date(entry.timestamp) > thirtyDaysAgo
        );
        
        // Keep max 500 entries
        if (data._changeLog.length > 500) {
            data._changeLog = data._changeLog.slice(0, 500);
        }
    }
    
    /**
     * Create a change log entry
     */
    function createChangeLogEntry(changeData) {
        return {
            id: `chg-${Date.now()}-${Math.random().toString(36).substr(2, 6)}`,
            timestamp: new Date().toISOString(),
            source: getAppIdentifier(),
            changeType: changeData.changeType || 'order',
            sku: changeData.sku || '',
            field: changeData.field || '',
            before: changeData.before,
            after: changeData.after,
            reason: changeData.reason || '',
            user: changeData.user || localStorage.getItem('ccd_hostname') || 'auto-process'
        };
    }

    // ============================================================
    // SHARED CONFIG SYSTEM - Core Functions
    // ============================================================
    
    /**
     * Get default settings for config file
     */
    function getDefaultConfigSettings() {
        return {
            autoProcessInterval: 5,
            autoProcessThreshold: 4,
            logRetention: 14,
            maxRetries: 3,
            enabledChannels: { etsy: true, wix: true, wayfair: true },
            proxyUrls: {
                etsy: 'https://script.google.com/macros/s/AKfycbwBwmSevqQliS2lbTZt-TKF83Mlim3Eol8jrhcK7sDTz2SK9_hG9STKqhl4RyZ_QK4GKQ/exec',
                wix: 'https://script.google.com/macros/s/AKfycbwpRDn1dBxgB-8dJOByOeGVQL0Ij3OiQYVUNAk-QWWEA8slhJxLFNK4UcN4CDQJA3r3/exec',
                wayfair: '',
                syncHub: 'https://script.google.com/macros/s/AKfycbxzScmS1LKEKb4h934Q0WT0Y_GZ3A-GMAeKIyJH0ZeUuJJ5uyHfEDyupXQYhOHEjbcg/exec',
                shippo: ''
            },
            ccdApiKey: 'ccd_VW5ORDOIcuh34shSTmbEwNjnrMVHTIdF',
            notifications: {
                email: '',
                ccEmail: '',
                events: {}
            }
        };
    }
    
    /**
     * Connect to existing config file
     */
    async function connectConfigFile() {
        try {
            const [handle] = await window.showOpenFilePicker({
                types: [{
                    description: 'CCD Config File',
                    accept: { 'application/json': ['.json'] }
                }],
                multiple: false
            });
            
            configFileHandle = handle;
            
            // Save handle for future sessions
            await saveFileHandle('configFile', handle);
            
            // Load the config
            await loadConfigFile();
            
            isSharedMode = true;
            updateConfigStatus(true);
            startConfigReloadInterval();
            startSharedHeartbeat();
            
            addLog('Config file connected - Shared Mode active', 'success');
            toast('Connected to shared config file!', 'success');
            
        } catch (error) {
            if (error.name !== 'AbortError') {
                console.error('Error connecting config file:', error);
                toast('Failed to connect config file: ' + error.message, 'error');
            }
        }
    }
    
    /**
     * Create a new config file
     */
    async function createConfigFile() {
        try {
            const handle = await window.showSaveFilePicker({
                suggestedName: 'ccd-system-CONFIG.json',
                types: [{
                    description: 'CCD Config File',
                    accept: { 'application/json': ['.json'] }
                }]
            });
            
            configFileHandle = handle;
            
            // Create initial config (migrate from localStorage)
            configData = createInitialConfigData();
            
            // Write to file
            const writable = await handle.createWritable();
            await writable.write(JSON.stringify(configData, null, 2));
            await writable.close();
            
            // Save handle for future sessions
            await saveFileHandle('configFile', handle);
            
            // Update tracking
            const newFile = await handle.getFile();
            configFileTimestamp = newFile.lastModified;
            configMetadataVersion = configData._metadata.version;
            
            isSharedMode = true;
            updateConfigStatus(true);
            startConfigReloadInterval();
            startSharedHeartbeat();
            
            addLog('New config file created - Shared Mode active', 'success');
            toast('Created new shared config file!', 'success');
            
        } catch (error) {
            if (error.name !== 'AbortError') {
                console.error('Error creating config file:', error);
                toast('Failed to create config file: ' + error.message, 'error');
            }
        }
    }
    
    /**
     * Disconnect from config file
     */
    async function disconnectConfigFile() {
        if (confirm('Disconnect from shared config file?\n\nSync Hub will use local settings only on this PC.')) {
            // Write final "stopped" heartbeat before disconnecting
            await writeSharedHeartbeat('stopped');
            
            // Clear IndexedDB handle
            if (db) {
                try {
                    const transaction = db.transaction([STORE_NAME], 'readwrite');
                    const store = transaction.objectStore(STORE_NAME);
                    store.delete('configFile');
                } catch (e) {
                    console.warn('Could not clear config handle:', e);
                }
            }
            
            configFileHandle = null;
            configData = null;
            isSharedMode = false;
            stopConfigReloadInterval();
            stopSharedHeartbeat();
            loadSettingsFromLocalStorage();
            updateConfigStatus(false);
            addLog('Disconnected from config file - Local Mode', 'info');
            toast('Disconnected - using local settings', 'info');
        }
    }
    
    /**
     * Load config file data
     */
    async function loadConfigFile() {
        if (!configFileHandle) {
            throw new Error('No config file connected');
        }
        
        const file = await configFileHandle.getFile();
        configFileTimestamp = file.lastModified;
        
        const content = await file.text();
        configData = JSON.parse(content);
        
        // Validate it's a config file - check for either fileType OR presence of expected structure
        const hasFileType = configData._metadata?.fileType === 'CCD_SYSTEM_CONFIG';
        const hasConfigStructure = configData._metadata && (configData.settings || configData.heartbeat !== undefined);
        
        if (!hasFileType && !hasConfigStructure) {
            throw new Error('Invalid config file format - missing _metadata or settings');
        }
        
        // Auto-fix: ensure fileType is set for future validation
        if (!hasFileType && hasConfigStructure) {
            configData._metadata.fileType = 'CCD_SYSTEM_CONFIG';
            configData._metadata.schemaVersion = configData._metadata.schemaVersion || '1.0';
            console.log('[Config] Auto-fixed missing fileType');
            // Save the fix
            try {
                const writable = await configFileHandle.createWritable();
                await writable.write(JSON.stringify(configData, null, 2));
                await writable.close();
                const newFile = await configFileHandle.getFile();
                configFileTimestamp = newFile.lastModified;
            } catch (e) {
                console.warn('Could not auto-fix config file:', e);
            }
        }
        
        // Ensure all required arrays exist
        configData.syncLogs = configData.syncLogs || [];
        configData.activityLog = configData.activityLog || [];
        configData.errorLog = configData.errorLog || [];
        configData.notificationQueue = configData.notificationQueue || [];
        configData.lastProcessed = configData.lastProcessed || {};
        configData.settings = configData.settings || getDefaultConfigSettings();
        
        configMetadataVersion = configData._metadata?.version || 0;
        
        // Apply settings to UI
        applySettingsFromConfig();
        
        // Update error log panel
        updateErrorLogPanel();
        
        return configData;
    }
    
    /**
     * Save config file with collision check
     */
    async function saveConfigFile(options = {}) {
        if (!configFileHandle) {
            // Fall back to localStorage
            saveSettingsToLocalStorage();
            return { saved: true, mode: 'local' };
        }
        
        const { actionDescription = 'Config update' } = options;
        
        // Collision check
        const collision = await checkConfigCollision();
        if (collision.collision) {
            console.log('Config collision detected, reloading...');
            await loadConfigFile();
            return { saved: false, reason: 'collision_reload' };
        }
        
        // Update metadata
        configData._metadata = configData._metadata || {};
        configData._metadata.version = (configData._metadata.version || 0) + 1;
        configData._metadata.lastModified = new Date().toISOString();
        configData._metadata.lastModifiedBy = getAppIdentifier();
        configData._metadata.fileType = 'CCD_SYSTEM_CONFIG';
        configData._metadata.schemaVersion = '1.0';
        
        // Prune old entries before saving
        pruneConfigEntries();
        
        // Save
        const writable = await configFileHandle.createWritable();
        await writable.write(JSON.stringify(configData, null, 2));
        await writable.close();
        
        // Update tracking
        const newFile = await configFileHandle.getFile();
        configFileTimestamp = newFile.lastModified;
        configMetadataVersion = configData._metadata.version;
        
        return { saved: true, mode: 'shared' };
    }
    
    /**
     * Check for config file collision
     */
    async function checkConfigCollision() {
        if (!configFileHandle) return { collision: false };
        
        try {
            const file = await configFileHandle.getFile();
            if (file.lastModified !== configFileTimestamp) {
                return { collision: true };
            }
            return { collision: false };
        } catch (error) {
            return { collision: false };
        }
    }
    
    /**
     * Prune old entries from config
     */
    function pruneConfigEntries() {
        if (!configData) return;
        
        const retentionDays = configData.settings?.logRetention || 14;
        const cutoff = new Date();
        cutoff.setDate(cutoff.getDate() - retentionDays);
        
        // Prune sync logs
        if (configData.syncLogs) {
            configData.syncLogs = configData.syncLogs.filter(log => 
                new Date(log.timestamp) > cutoff
            );
        }
        
        // Keep activity log to 200 entries
        if (configData.activityLog && configData.activityLog.length > 200) {
            configData.activityLog = configData.activityLog.slice(0, 200);
        }
        
        // Keep error log to 100 entries
        if (configData.errorLog && configData.errorLog.length > 100) {
            configData.errorLog = configData.errorLog.slice(0, 100);
        }
        
        // Keep notification queue to 100 entries
        if (configData.notificationQueue && configData.notificationQueue.length > 100) {
            configData.notificationQueue = configData.notificationQueue.slice(0, 100);
        }
    }
    
    /**
     * Create initial config data (migrating from localStorage)
     */
    function createInitialConfigData() {
        return {
            _metadata: {
                version: 1,
                lastModified: new Date().toISOString(),
                lastModifiedBy: getAppIdentifier(),
                fileType: 'CCD_SYSTEM_CONFIG',
                schemaVersion: '1.0'
            },
            settings: migrateSettingsToConfig(),
            lastProcessed: migrateLastProcessedToConfig(),
            syncLogs: migrateSyncLogsToConfig(),
            activityLog: migrateActivityLogToConfig(),
            errorLog: [],
            notificationQueue: [],
            heartbeat: null
        };
    }
    
    function migrateSettingsToConfig() {
        const saved = localStorage.getItem('ccd_sync_hub_settings');
        if (saved) {
            try {
                return { ...getDefaultConfigSettings(), ...JSON.parse(saved) };
            } catch (e) {}
        }
        return getDefaultConfigSettings();
    }
    
    function migrateSyncLogsToConfig() {
        const saved = localStorage.getItem('ccd_sync_log');
        if (saved) {
            try {
                return JSON.parse(saved);
            } catch (e) {}
        }
        return [];
    }
    
    function migrateActivityLogToConfig() {
        const saved = localStorage.getItem('ccd_activity_log');
        if (saved) {
            try {
                return JSON.parse(saved);
            } catch (e) {}
        }
        return [];
    }
    
    function migrateLastProcessedToConfig() {
        const saved = localStorage.getItem('ccd_last_processed');
        if (saved) {
            try {
                return JSON.parse(saved);
            } catch (e) {}
        }
        return {};
    }
    
    /**
     * Apply settings from config to UI
     */
    function applySettingsFromConfig() {
        if (!configData || !configData.settings) return;
        
        const settings = configData.settings;
        
        // Merge into state.settings
        state.settings = {
            ...state.settings,
            ccdApiKey: settings.ccdApiKey || state.settings.ccdApiKey,
            etsyProxyUrl: settings.proxyUrls?.etsy || '',
            wixProxyUrl: settings.proxyUrls?.wix || state.settings.wixProxyUrl,
            wayfairProxyUrl: settings.proxyUrls?.wayfair || '',
            shippoProxyUrl: settings.proxyUrls?.shippo || '',
            syncHubProxyUrl: settings.proxyUrls?.syncHub || state.settings.syncHubProxyUrl,
            autoProcessEnabled: settings.autoProcessEnabled || false,
            retryFailedEnabled: settings.retryFailedEnabled !== false,
            maxRetries: settings.maxRetries || 3
        };
        
        // Update UI
        const elements = {
            'ccdApiKey': state.settings.ccdApiKey,
            'etsyProxyUrl': state.settings.etsyProxyUrl,
            'wixProxyUrl': state.settings.wixProxyUrl,
            'wayfairProxyUrl': state.settings.wayfairProxyUrl,
            'shippoProxyUrl': state.settings.shippoProxyUrl,
            'syncHubProxyUrl': state.settings.syncHubProxyUrl,
            'syncHubProxyUrlSettings': state.settings.syncHubProxyUrl
        };
        
        for (const [id, value] of Object.entries(elements)) {
            const el = document.getElementById(id);
            if (el) el.value = value || '';
        }
        
        const autoProcessEl = document.getElementById('autoProcessEnabled');
        if (autoProcessEl) autoProcessEl.checked = state.settings.autoProcessEnabled;
        
        const retryEl = document.getElementById('retryFailedEnabled');
        if (retryEl) retryEl.checked = state.settings.retryFailedEnabled;
    }
    
    /**
     * Load settings from localStorage (fallback)
     */
    function loadSettingsFromLocalStorage() {
        const saved = localStorage.getItem('ccd_sync_hub_settings');
        if (saved) {
            try {
                const loaded = JSON.parse(saved);
                state.settings = { ...state.settings, ...loaded };
            } catch (e) {
                console.error('Error loading settings:', e);
            }
        }
        
        // Populate form
        document.getElementById('ccdApiKey').value = state.settings.ccdApiKey || '';
        document.getElementById('etsyApiKey').value = state.settings.etsyApiKey || '';
        document.getElementById('etsyProxyUrl').value = state.settings.etsyProxyUrl || '';
        document.getElementById('wixProxyUrl').value = state.settings.wixProxyUrl || '';
        document.getElementById('wayfairProxyUrl').value = state.settings.wayfairProxyUrl || '';
        document.getElementById('shippoProxyUrl').value = state.settings.shippoProxyUrl || '';
        document.getElementById('syncHubProxyUrl').value = state.settings.syncHubProxyUrl || '';
        document.getElementById('syncHubProxyUrlSettings').value = state.settings.syncHubProxyUrl || '';
        document.getElementById('autoProcessEnabled').checked = state.settings.autoProcessEnabled || false;
        document.getElementById('retryFailedEnabled').checked = state.settings.retryFailedEnabled !== false;
    }
    
    /**
     * Save settings to localStorage (fallback)
     */
    function saveSettingsToLocalStorage() {
        localStorage.setItem('ccd_sync_hub_settings', JSON.stringify(state.settings));
    }
    
    /**
     * Auto-reload config when changed by another PC
     */
    function startConfigReloadInterval() {
        if (configReloadInterval) clearInterval(configReloadInterval);
        
        configReloadInterval = setInterval(async () => {
            if (!configFileHandle || !isSharedMode) return;
            
            try {
                const file = await configFileHandle.getFile();
                
                if (file.lastModified !== configFileTimestamp) {
                    console.log('Config file changed by another PC, reloading...');
                    
                    const oldSettings = JSON.stringify(configData?.settings || {});
                    await loadConfigFile();
                    const newSettings = JSON.stringify(configData?.settings || {});
                    
                    if (oldSettings !== newSettings) {
                        addLog('Settings updated by another PC - reloaded', 'info');
                        toast('Settings updated by another PC', 'info');
                    }
                }
            } catch (error) {
                console.error('Config reload check error:', error);
            }
        }, 30000); // 30 seconds
    }
    
    function stopConfigReloadInterval() {
        if (configReloadInterval) {
            clearInterval(configReloadInterval);
            configReloadInterval = null;
        }
    }
    
    /**
     * Update config status UI
     */
    function updateConfigStatus(connected) {
        const statusEl = document.getElementById('configStatus');
        const modeBadge = document.getElementById('configModeBadge');
        const connectBtn = document.getElementById('btnConnectConfig');
        const createBtn = document.getElementById('btnCreateConfig');
        const disconnectBtn = document.getElementById('btnDisconnectConfig');
        const errorPanel = document.getElementById('sharedErrorLogPanel');
        
        if (connected) {
            if (statusEl) {
                statusEl.className = 'config-status-banner connected';
                statusEl.innerHTML = `
                    <span class="config-status-dot green"></span>
                    <strong>Shared Mode</strong> - Connected to config file
                    <br><small style="color: var(--text-dim);">Settings and logs sync across all PCs</small>
                `;
            }
            if (modeBadge) {
                modeBadge.className = 'mode-badge shared';
                modeBadge.textContent = 'SHARED MODE';
            }
            if (connectBtn) connectBtn.style.display = 'none';
            if (createBtn) createBtn.style.display = 'none';
            if (disconnectBtn) disconnectBtn.style.display = 'inline-flex';
            if (errorPanel) errorPanel.style.display = 'block';
        } else {
            if (statusEl) {
                statusEl.className = 'config-status-banner disconnected';
                statusEl.innerHTML = `
                    <span class="config-status-dot yellow"></span>
                    <strong>Local Mode</strong> - Using browser storage only
                    <br><small style="color: var(--text-dim);">Settings and logs are not shared with other PCs</small>
                `;
            }
            if (modeBadge) {
                modeBadge.className = 'mode-badge local';
                modeBadge.textContent = 'LOCAL MODE';
            }
            if (connectBtn) connectBtn.style.display = 'inline-flex';
            if (createBtn) createBtn.style.display = 'inline-flex';
            if (disconnectBtn) disconnectBtn.style.display = 'none';
            if (errorPanel) errorPanel.style.display = 'none';
        }
    }
    
    // ============================================================
    // SHARED HEARTBEAT SYSTEM
    // ============================================================
    
    function startSharedHeartbeat() {
        if (heartbeatInterval) clearInterval(heartbeatInterval);
        
        // Write immediately
        writeSharedHeartbeat();
        
        // Then every 60 seconds
        heartbeatInterval = setInterval(() => writeSharedHeartbeat(), 60000);
    }
    
    function stopSharedHeartbeat() {
        if (heartbeatInterval) {
            clearInterval(heartbeatInterval);
            heartbeatInterval = null;
        }
    }
    
    async function writeSharedHeartbeat(status = 'running') {
        if (!isSharedMode || !configData || !configFileHandle) return;
        
        const autoEnabled = document.getElementById('autoProcessEnabled')?.checked || false;
        
        // Calculate next run time
        let nextRunAt = null;
        if (autoEnabled && autoProcessNextRun) {
            nextRunAt = autoProcessNextRun.toISOString();
        }
        
        configData.heartbeat = {
            timestamp: new Date().toISOString(),
            source: getAppIdentifier(),
            autoProcessEnabled: autoEnabled,
            autoProcessInterval: configData.settings?.autoProcessInterval || 5,
            nextRunAt: nextRunAt,
            lastOrderProcessed: lastProcessedOrderId || null,
            status: status  // 'running', 'stopped', 'paused', 'error'
        };
        
        // Save without triggering full save logic (lightweight)
        try {
            const writable = await configFileHandle.createWritable();
            await writable.write(JSON.stringify(configData, null, 2));
            await writable.close();
            
            const file = await configFileHandle.getFile();
            configFileTimestamp = file.lastModified;
        } catch (error) {
            console.error('Heartbeat write error:', error);
        }
    }
    
    function updateNextRunTime() {
        const intervalMinutes = configData?.settings?.autoProcessInterval || 5;
        const intervalMs = intervalMinutes * 60 * 1000;
        autoProcessNextRun = new Date(Date.now() + intervalMs);
    }
    
    function setLastProcessedOrderForHeartbeat(orderId) {
        lastProcessedOrderId = orderId;
    }
    
    // ============================================================
    // SHARED ERROR LOG SYSTEM
    // ============================================================
    
    function getSharedErrorLog() {
        if (isSharedMode && configData) {
            return configData.errorLog || [];
        }
        return JSON.parse(localStorage.getItem('ccd_error_log') || '[]');
    }
    
    async function logSharedError(message, category, context = {}, severity = 'error') {
        const entry = {
            id: `err-${Date.now()}-${Math.random().toString(36).substr(2, 6)}`,
            timestamp: new Date().toISOString(),
            source: getAppIdentifier(),
            severity: severity,
            category: category,
            message: message,
            context: context,
            resolved: false
        };
        
        if (isSharedMode && configData) {
            configData.errorLog = configData.errorLog || [];
            configData.errorLog.unshift(entry);
            if (configData.errorLog.length > 100) {
                configData.errorLog = configData.errorLog.slice(0, 100);
            }
            scheduleConfigSave();
        } else {
            const logs = JSON.parse(localStorage.getItem('ccd_error_log') || '[]');
            logs.unshift(entry);
            localStorage.setItem('ccd_error_log', JSON.stringify(logs.slice(0, 100)));
        }
        
        // Also add to activity log
        addLog(`‚ùå ${severity.toUpperCase()}: ${message}`, 'error');
        
        // Update error panel
        updateErrorLogPanel();
        
        return entry;
    }
    
    async function resolveSharedError(errorId) {
        if (isSharedMode && configData) {
            const error = configData.errorLog?.find(e => e.id === errorId);
            if (error) {
                error.resolved = true;
                error.resolvedAt = new Date().toISOString();
                error.resolvedBy = getAppIdentifier();
                await saveConfigFile({ actionDescription: 'Error resolved' });
                updateErrorLogPanel();
            }
        }
    }
    
    function updateErrorLogPanel() {
        const list = document.getElementById('sharedErrorLogList');
        if (!list) return;
        
        const errors = getSharedErrorLog().slice(0, 10);
        
        if (errors.length === 0) {
            list.innerHTML = '<div style="padding: 16px; color: var(--text-dim); text-align: center;">No errors logged</div>';
            return;
        }
        
        list.innerHTML = errors.map(err => `
            <div class="error-log-item ${err.resolved ? 'resolved' : ''}">
                <span class="error-severity ${err.severity}">${err.severity.toUpperCase()}</span>
                <div style="flex: 1;">
                    <div style="font-weight: 500;">${err.message}</div>
                    <div style="font-size: 0.75rem; color: var(--text-dim);">
                        ${new Date(err.timestamp).toLocaleString()} ‚Ä¢ ${err.source}
                        ${err.resolved ? '<span style="color: var(--success);"> ‚Ä¢ Resolved</span>' : ''}
                    </div>
                </div>
                ${!err.resolved ? `<button class="btn btn-sm btn-secondary" onclick="resolveSharedError('${err.id}')">‚úì</button>` : ''}
            </div>
        `).join('');
    }
    
    function refreshErrorLog() {
        if (isSharedMode && configFileHandle) {
            loadConfigFile().then(() => {
                updateErrorLogPanel();
                toast('Error log refreshed', 'success');
            });
        }
    }
    
    // Debounced save to avoid too many writes
    function scheduleConfigSave() {
        if (configSaveTimeout) clearTimeout(configSaveTimeout);
        configSaveTimeout = setTimeout(async () => {
            await saveConfigFile({ actionDescription: 'Activity logged' });
        }, 5000);
    }
    
    // ============================================================
    // SHARED SYNC LOGS
    // ============================================================
    
    function getSharedSyncLogs() {
        if (isSharedMode && configData) {
            return configData.syncLogs || [];
        }
        return JSON.parse(localStorage.getItem('ccd_sync_log') || '[]');
    }
    
    async function addSharedSyncLog(entry) {
        if (isSharedMode && configData) {
            configData.syncLogs = configData.syncLogs || [];
            configData.syncLogs.unshift(entry);
            await saveConfigFile({ actionDescription: `Sync: ${entry.orderId}` });
        } else {
            const logs = JSON.parse(localStorage.getItem('ccd_sync_log') || '[]');
            logs.unshift(entry);
            localStorage.setItem('ccd_sync_log', JSON.stringify(logs.slice(0, 500)));
        }
    }
    
    function findSyncLogByOrderAndSku(orderId, sku) {
        const logs = getSharedSyncLogs();
        return logs.find(log => log.orderId === orderId && log.sku === sku);
    }
    
    // ============================================================
    // SHARED ACTIVITY LOG
    // ============================================================
    
    function getSharedActivityLog() {
        if (isSharedMode && configData) {
            return configData.activityLog || [];
        }
        return JSON.parse(localStorage.getItem('ccd_activity_log') || '[]');
    }
    
    async function addSharedActivity(message, level = 'info') {
        const entry = {
            timestamp: new Date().toISOString(),
            source: getAppIdentifier(),
            level: level,
            message: message
        };
        
        if (isSharedMode && configData) {
            configData.activityLog = configData.activityLog || [];
            configData.activityLog.unshift(entry);
            scheduleConfigSave();
        } else {
            const logs = JSON.parse(localStorage.getItem('ccd_activity_log') || '[]');
            logs.unshift(entry);
            localStorage.setItem('ccd_activity_log', JSON.stringify(logs.slice(0, 200)));
        }
        
        return entry;
    }
    
    // ============================================================
    // SHARED LAST PROCESSED
    // ============================================================
    
    function getLastProcessed(channel) {
        if (isSharedMode && configData) {
            return configData.lastProcessed?.[channel] || null;
        }
        const data = JSON.parse(localStorage.getItem('ccd_last_processed') || '{}');
        return data[channel] || null;
    }
    
    async function setLastProcessed(channel, orderId, timestamp) {
        const entry = { orderId, timestamp };
        
        if (isSharedMode && configData) {
            configData.lastProcessed = configData.lastProcessed || {};
            configData.lastProcessed[channel] = entry;
            await saveConfigFile({ actionDescription: `Last processed: ${channel}` });
        } else {
            const data = JSON.parse(localStorage.getItem('ccd_last_processed') || '{}');
            data[channel] = entry;
            localStorage.setItem('ccd_last_processed', JSON.stringify(data));
        }
    }
    
    // ============================================================
    // TRY RECONNECT CONFIG ON STARTUP
    // ============================================================
    
    async function tryReconnectConfig() {
        try {
            const handle = await loadFileHandle('configFile');
            if (!handle) {
                console.log('[Config] No saved config file handle - first time setup required');
                return false;
            }
            
            console.log('[Config] Found saved file handle, checking permission...');
            const permission = await handle.queryPermission({ mode: 'readwrite' });
            console.log('[Config] Permission status:', permission);
            
            if (permission === 'granted') {
                configFileHandle = handle;
                await loadConfigFile();
                isSharedMode = true;
                updateConfigStatus(true);
                startConfigReloadInterval();
                startSharedHeartbeat();
                console.log('[Config] ‚úÖ Auto-reconnected successfully');
                addLog('Config file restored - Shared Mode active', 'success');
                return true;
            } else if (permission === 'prompt') {
                // Need to request permission - show user-friendly message
                console.log('[Config] Permission needed - requesting...');
                addLog('‚ö†Ô∏è Config file permission needed - click to grant', 'warning');
                
                try {
                    const newPermission = await handle.requestPermission({ mode: 'readwrite' });
                    if (newPermission === 'granted') {
                        configFileHandle = handle;
                        await loadConfigFile();
                        isSharedMode = true;
                        updateConfigStatus(true);
                        startConfigReloadInterval();
                        startSharedHeartbeat();
                        console.log('[Config] ‚úÖ Permission granted - reconnected');
                        addLog('Config file permission re-granted - Shared Mode active', 'success');
                        return true;
                    } else {
                        console.log('[Config] ‚ùå Permission denied by user');
                        addLog('Config file permission denied - please reconnect manually', 'error');
                    }
                } catch (permErr) {
                    console.error('[Config] ‚ùå Permission request failed:', permErr);
                    addLog('Config file permission request failed - please reconnect manually', 'error');
                }
            } else {
                // Permission denied
                console.log('[Config] ‚ùå Permission denied - manual reconnect required');
                addLog('Config file permission denied - please reconnect manually', 'error');
            }
        } catch (e) {
            console.error('[Config] ‚ùå Auto-reconnect error:', e);
            addLog('Config auto-reconnect failed: ' + e.message, 'error');
        }
        return false;
    }

    const state = {
        queue: [],
        processing: false,
        connections: { etsy: false, wix: false, wayfair: false, shippo: false, syncHub: false, masterJson: false },
        activityLog: [],
        autoProcessInterval: null,
        // Auto-sync state - v3.9
        autoPollInterval: null,
        autoPollCountdown: null,
        autoPollWorker: null,
        autoPollWatchdog: null,
        lastPollTime: null,
        pollGapWarningShown: false,
        autoPushWatchInterval: null,
        inventorySnapshot: {},
        autoSyncLog: [],
        // Orders from all channels
        orders: {
            etsy: [],
            wix: [],
            wayfair: [],
            all: [],
            processedIds: new Set() // Track processed order IDs to prevent duplicates
        },
        lowStockItems: [],
        lowStockNotificationSent: false, // Prevent spam - only notify once per session
        currentOrdersTab: 'all',
        masterJson: {
            fileName: null,
            lastLoaded: null,
            productCount: 0,
            etsyLinked: 0,
            wixLinked: 0,
            wayfairLinked: 0
        },
        settings: {
            ccdApiKey: 'ccd_VW5ORDOIcuh34shSTmbEwNjnrMVHTIdF',
            etsyApiKey: '', // If blank, uses ccdApiKey
            etsyProxyUrl: '',
            wixProxyUrl: 'https://script.google.com/macros/s/AKfycbwg2Qphxj0yYqGmgAB9NRrv7_gLQZfLQSOBgdBVnmWAJusURelVVbZ3uO0J3wxUVXmt/exec',
            wayfairProxyUrl: '',
            shippoProxyUrl: '',
            syncHubProxyUrl: 'https://script.google.com/macros/s/AKfycbxzScmS1LKEKb4h934Q0WT0Y_GZ3A-GMAeKIyJH0ZeUuJJ5uyHfEDyupXQYhOHEjbcg/exec',
            autoProcessEnabled: false,
            retryFailedEnabled: true,
            maxRetries: 3,
            // Channel sync toggles
            enableEtsySync: true,
            enableWixSync: true,
            enableWayfairSync: true,
            // Auto-sync settings - v3.9
            autoPollEnabled: false,
            autoPollIntervalMinutes: 15,
            autoPushEnabled: false,
            autoPushEtsy: true,
            autoPushWix: true,
            autoPushWayfair: true,
            alertZeroStock: true,
            alertMismatch: true,
            alertSyncErrors: true
        }
    };

    // =============================================
    // INDEXEDDB - FILE HANDLE PERSISTENCE
    // =============================================
    const DB_NAME = 'CCD_SyncHub_DB';
    const DB_VERSION = 1;
    const STORE_NAME = 'fileHandles';
    let db = null;
    
    async function initDB() {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(DB_NAME, DB_VERSION);
            
            request.onerror = () => {
                console.error('[IndexedDB] Error opening database:', request.error);
                reject(request.error);
            };
            
            request.onsuccess = () => {
                db = request.result;
                console.log('[IndexedDB] Database opened successfully');
                resolve(db);
            };
            
            request.onupgradeneeded = (event) => {
                const database = event.target.result;
                if (!database.objectStoreNames.contains(STORE_NAME)) {
                    database.createObjectStore(STORE_NAME);
                    console.log('[IndexedDB] Created file handles store');
                }
            };
        });
    }
    
    async function saveFileHandle(key, handle) {
        if (!db) await initDB();
        return new Promise((resolve, reject) => {
            try {
                const transaction = db.transaction([STORE_NAME], 'readwrite');
                const store = transaction.objectStore(STORE_NAME);
                const request = store.put(handle, key);
                request.onsuccess = () => resolve(true);
                request.onerror = () => reject(request.error);
            } catch (e) {
                reject(e);
            }
        });
    }
    
    async function loadFileHandle(key) {
        if (!db) await initDB();
        return new Promise((resolve, reject) => {
            try {
                const transaction = db.transaction([STORE_NAME], 'readonly');
                const store = transaction.objectStore(STORE_NAME);
                const request = store.get(key);
                request.onsuccess = () => resolve(request.result || null);
                request.onerror = () => reject(request.error);
            } catch (e) {
                reject(e);
            }
        });
    }
    
    // ============================================================
    // SYNC DATA FILE FUNCTIONS (v3.9)
    // Write orders from all channels to ccd-sync-data.json
    // ============================================================
    
    /**
     * Connect to ccd-sync-data.json file
     */
    async function connectSyncDataFile() {
        try {
            const [handle] = await window.showOpenFilePicker({
                types: [{
                    description: 'Sync Data JSON',
                    accept: { 'application/json': ['.json'] }
                }],
                multiple: false
            });
            
            const permission = await handle.requestPermission({ mode: 'readwrite' });
            if (permission !== 'granted') {
                toast('‚ùå Permission denied for sync data file', 'error');
                return false;
            }
            
            syncDataFileHandle = handle;
            await saveFileHandle('syncDataFile', handle);
            
            // Load existing data
            await loadSyncDataFile();
            
            updateSyncDataStatus(true, handle.name);
            toast('‚úÖ Connected to ' + handle.name, 'success');
            addLog(`Sync data file connected: ${handle.name}`, 'success');
            
            return true;
        } catch (e) {
            if (e.name !== 'AbortError') {
                console.error('[Sync Data] Connection error:', e);
                toast('‚ùå Failed to connect sync data file', 'error');
            }
            return false;
        }
    }
    
    /**
     * Load data from sync data file
     */
    async function loadSyncDataFile() {
        if (!syncDataFileHandle) return;
        
        try {
            const file = await syncDataFileHandle.getFile();
            const text = await file.text();
            const data = JSON.parse(text);
            
            // Merge with cache
            syncDataCache = {
                etsy: data.etsy || { orders: [], lastSync: null },
                wix: data.wix || { orders: [], lastSync: null },
                wayfair: data.wayfair || { orders: [], lastSync: null },
                _metadata: data._metadata || { version: 0, lastModified: null }
            };
            
            console.log(`[Sync Data] Loaded: Etsy(${syncDataCache.etsy.orders.length}), Wix(${syncDataCache.wix.orders.length}), Wayfair(${syncDataCache.wayfair.orders.length})`);
            return true;
        } catch (e) {
            console.error('[Sync Data] Load error:', e);
            return false;
        }
    }
    
    /**
     * Save current orders to sync data file
     */
    async function saveSyncDataFile() {
        if (!syncDataFileHandle) {
            console.log('[Sync Data] No file connected - skipping save');
            return false;
        }
        
        try {
            // Update cache with current orders
            const now = new Date().toISOString();
            
            if (state.orders.etsy.length > 0) {
                syncDataCache.etsy = {
                    orders: state.orders.etsy,
                    lastSync: now
                };
            }
            
            if (state.orders.wix.length > 0) {
                syncDataCache.wix = {
                    orders: state.orders.wix,
                    lastSync: now
                };
            }
            
            if (state.orders.wayfair.length > 0) {
                syncDataCache.wayfair = {
                    orders: state.orders.wayfair,
                    lastSync: now
                };
            }
            
            // Update metadata
            syncDataCache._metadata = {
                version: (syncDataCache._metadata?.version || 0) + 1,
                lastModified: now,
                lastModifiedBy: localStorage.getItem('ccd_hostname') || 'Sync Hub'
            };
            
            // Write to file
            const writable = await syncDataFileHandle.createWritable();
            await writable.write(JSON.stringify(syncDataCache, null, 2));
            await writable.close();
            
            console.log(`[Sync Data] Saved: Etsy(${syncDataCache.etsy.orders.length}), Wix(${syncDataCache.wix.orders.length}), Wayfair(${syncDataCache.wayfair.orders.length})`);
            return true;
        } catch (e) {
            console.error('[Sync Data] Save error:', e);
            addLog(`Sync data save failed: ${e.message}`, 'error');
            
            sendEventNotification(
                'sync.failed',
                `Sync data save failed: ${e.message}`,
                { error: e.message, type: 'sync_data_save' }
            );
            
            return false;
        }
    }
    
    /**
     * Try to reconnect to sync data file on startup
     */
    async function tryReconnectSyncDataFile() {
        try {
            // v3.9: Check Command Center shared files first
            if (typeof CCDSharedFiles !== 'undefined') {
                const sharedHandle = await CCDSharedFiles.getSyncData();
                if (sharedHandle) {
                    syncDataFileHandle = sharedHandle;
                    await loadSyncDataFile();
                    updateSyncDataStatus(true, 'Shared via Command Center');
                    console.log('[Sync Data] Connected via Command Center shared files');
                    return true;
                }
            }
            
            // Fall back to own stored handle
            const handle = await loadFileHandle('syncDataFile');
            if (!handle) {
                console.log('[Sync Data] No saved file handle');
                return false;
            }
            
            const permission = await handle.queryPermission({ mode: 'readwrite' });
            if (permission === 'granted') {
                syncDataFileHandle = handle;
                await loadSyncDataFile();
                updateSyncDataStatus(true, handle.name);
                console.log('[Sync Data] Auto-reconnected successfully');
                return true;
            } else {
                console.log('[Sync Data] Permission needed - show reconnect UI');
                return false;
            }
        } catch (e) {
            console.log('[Sync Data] Auto-reconnect failed:', e.message);
            return false;
        }
    }
    
    /**
     * Update sync data file status in UI
     */
    function updateSyncDataStatus(connected, fileName = '') {
        const statusEl = document.getElementById('syncDataFileStatus');
        const nameEl = document.getElementById('syncDataFileName');
        const detailsEl = document.getElementById('syncDataDetails');
        const statsEl = document.getElementById('syncDataStats');
        
        if (statusEl) {
            const dot = statusEl.querySelector('.connection-dot');
            const text = statusEl.querySelector('.status-text');
            if (dot) dot.className = 'connection-dot ' + (connected ? 'connected' : 'disconnected');
            if (text) text.textContent = connected ? 'Connected' : 'Not Connected';
        }
        if (nameEl) {
            nameEl.textContent = connected ? fileName : 'No file selected';
        }
        if (detailsEl && connected) {
            detailsEl.textContent = `Last modified: ${syncDataCache._metadata?.lastModified ? new Date(syncDataCache._metadata.lastModified).toLocaleString() : 'Unknown'}`;
        }
        if (statsEl && connected) {
            statsEl.style.display = 'block';
            document.getElementById('syncDataEtsyOrders').textContent = syncDataCache.etsy?.orders?.length || 0;
            document.getElementById('syncDataWixOrders').textContent = syncDataCache.wix?.orders?.length || 0;
            document.getElementById('syncDataWayfairOrders').textContent = syncDataCache.wayfair?.orders?.length || 0;
        }
    }
    
    /**
     * Create a new sync data file
     */
    async function createSyncDataFile() {
        try {
            const handle = await window.showSaveFilePicker({
                suggestedName: 'ccd-sync-data.json',
                types: [{
                    description: 'Sync Data JSON',
                    accept: { 'application/json': ['.json'] }
                }]
            });
            
            // Initialize with empty structure
            const initialData = {
                etsy: { orders: [], lastSync: null },
                wix: { orders: [], lastSync: null },
                wayfair: { orders: [], lastSync: null },
                _metadata: {
                    version: 1,
                    lastModified: new Date().toISOString(),
                    lastModifiedBy: localStorage.getItem('ccd_hostname') || 'Sync Hub',
                    created: new Date().toISOString()
                }
            };
            
            // Write initial data
            const writable = await handle.createWritable();
            await writable.write(JSON.stringify(initialData, null, 2));
            await writable.close();
            
            // Save handle and set as active
            syncDataFileHandle = handle;
            syncDataCache = initialData;
            await saveFileHandle('syncDataFile', handle);
            
            updateSyncDataStatus(true, handle.name);
            toast('‚úÖ Created ' + handle.name, 'success');
            addLog(`Created new sync data file: ${handle.name}`, 'success');
            
        } catch (e) {
            if (e.name !== 'AbortError') {
                console.error('[Sync Data] Create error:', e);
                toast('‚ùå Failed to create sync data file', 'error');
            }
        }
    }
    
    async function tryReconnectMasterJson() {
        try {
            // v3.9: Check Command Center shared files first
            if (typeof CCDSharedFiles !== 'undefined') {
                const sharedHandle = await CCDSharedFiles.getMasterJson();
                if (sharedHandle) {
                    masterJsonFileHandle = sharedHandle;
                    await loadMasterJson();
                    console.log('[Master JSON] ‚úÖ Connected via Command Center shared files');
                    toast('Master JSON connected (shared)', 'success');
                    return true;
                }
            }
            
            // Fall back to own stored handle
            const handle = await loadFileHandle('masterJson');
            if (!handle) {
                console.log('[Master JSON] No saved file handle - first time setup required');
                return false;
            }
            
            console.log('[Master JSON] Found saved file handle, checking permission...');
            // Check/request permission
            const permission = await handle.queryPermission({ mode: 'readwrite' });
            console.log('[Master JSON] Permission status:', permission);
            
            if (permission === 'granted') {
                masterJsonFileHandle = handle;
                await loadMasterJson();
                console.log('[Master JSON] ‚úÖ Auto-reconnected successfully');
                toast('Master JSON auto-connected', 'success');
                return true;
            } else if (permission === 'prompt') {
                // Try to request permission automatically
                console.log('[Master JSON] Permission needed - requesting...');
                try {
                    const newPermission = await handle.requestPermission({ mode: 'readwrite' });
                    if (newPermission === 'granted') {
                        masterJsonFileHandle = handle;
                        await loadMasterJson();
                        console.log('[Master JSON] ‚úÖ Permission granted - reconnected');
                        toast('Master JSON reconnected', 'success');
                        return true;
                    } else {
                        console.log('[Master JSON] ‚ùå Permission denied');
                        showMasterJsonReconnectBanner(handle.name);
                        masterJsonFileHandle = handle;
                        return false;
                    }
                } catch (permErr) {
                    console.error('[Master JSON] ‚ùå Permission request failed:', permErr);
                    showMasterJsonReconnectBanner(handle.name);
                    masterJsonFileHandle = handle;
                    return false;
                }
            } else {
                // Permission denied - show banner
                console.log('[Master JSON] ‚ùå Permission denied - user must click to reconnect');
                localStorage.setItem('ccd_master_json_pending', handle.name);
                showMasterJsonReconnectBanner(handle.name);
                masterJsonFileHandle = handle;
                return false;
            }
        } catch (e) {
            console.error('[Master JSON] ‚ùå Auto-reconnect error:', e);
            toast('Master JSON auto-reconnect failed: ' + e.message, 'error');
            return false;
        }
    }
    
    function showMasterJsonReconnectBanner(fileName) {
        const banner = document.getElementById('masterJsonReconnectBanner');
        const fileNameSpan = document.getElementById('reconnectFileName');
        if (banner && fileNameSpan) {
            fileNameSpan.textContent = fileName;
            banner.style.display = 'block';
        }
    }
    
    async function reconnectMasterJson() {
        if (!masterJsonFileHandle) {
            toast('No previous file to reconnect', 'warning');
            return;
        }
        
        try {
            const permission = await masterJsonFileHandle.requestPermission({ mode: 'readwrite' });
            if (permission === 'granted') {
                await loadMasterJson();
                document.getElementById('masterJsonReconnectBanner').style.display = 'none';
                localStorage.removeItem('ccd_master_json_pending');
                toast('Reconnected to Master JSON', 'success');
            } else {
                toast('Permission denied', 'error');
            }
        } catch (e) {
            toast('Reconnection failed: ' + e.message, 'error');
        }
    }

    // =============================================
    // INITIALIZATION
    // =============================================
    async function init() {
        try {
            console.log('[Init] Starting CCD Sync Hub v3.2.0...');
            
            // COLLISION DETECTION: Ensure hostname is set for tracking
            ensureHostnameSet();
            
            // Initialize IndexedDB first
            await initDB();
            
            // Try to auto-reconnect to Config file first
            const configConnected = await tryReconnectConfig();
            
            // If no config file, load from localStorage
            if (!configConnected) {
                loadSettings();
                updateConfigStatus(false);
            }
            
            // Try to auto-reconnect to Master JSON (needed for shared queue)
            await tryReconnectMasterJson();
            
            // Load queue (GAP 1 - now async to support shared queue)
            await loadQueue();
            
            loadLog();
            loadProcessedOrders();
            renderQueue();
            updateStats();
            renderLog();
            
            // Load channel toggle states into UI
            loadChannelToggles();
            
            // Try to auto-reconnect to Sync Data file (v3.9)
            await tryReconnectSyncDataFile();
            
            // Auto-test all channel connections on startup
            await autoTestAllConnections();

            if (state.settings.autoProcessEnabled) {
                startAutoProcess();
            }

            // Auto-refresh queue every 30 seconds
            setInterval(async () => {
                await loadQueue();
                renderQueue();
                updateStats();
            }, 30000);
            
            // Set up custom date range toggle
            const pullTimeRange = document.getElementById('pullTimeRange');
            if (pullTimeRange) {
                pullTimeRange.addEventListener('change', function() {
                    const customRange = document.getElementById('customDateRange');
                    if (customRange) customRange.style.display = this.value === 'custom' ? 'block' : 'none';
                });
            }
            
            // Start heartbeat for cross-app communication (localStorage - for Channel Manager)
            startHeartbeat();
            
            // Load auto-sync settings (v3.9)
            loadAutoSyncSettings();
            
            // Load notification settings from Sync Hub proxy (v3.2.1 fix)
            setTimeout(() => {
                loadNotificationSettings();
            }, 1000); // Delay to ensure connection is established
            
            console.log('[Init] CCD Sync Hub v3.2.0 initialized successfully');
            addLog('CCD Sync Hub v3.2.0 initialized (Resilient Polling)', 'success');
            
            // Log startup to Activity Log (only if Master JSON is connected)
            if (typeof logActivity === 'function' && masterJsonData) {
                logActivity('system', 'sync_hub_started', 'system',
                    'Sync Hub v3.2.0 started (Resilient Polling)',
                    { autoProcess: state.settings.autoProcessEnabled, configConnected: configConnected, sharedQueue: configData?.settings?.features?.useSharedQueue ?? false }
                );
            }
        } catch (error) {
            console.error('[Init] Error:', error);
            logError(`Init failed: ${error.message}`);
        }
        
        // Set default dates for custom range
        const now = new Date();
        const yesterday = new Date(now - 24 * 60 * 60 * 1000);
        document.getElementById('pullEndDate').value = now.toISOString().slice(0, 16);
        document.getElementById('pullStartDate').value = yesterday.toISOString().slice(0, 16);
    }
    
    /**
     * Write heartbeat to localStorage so Channel Manager can detect if Sync Hub is running
     */
    function writeHeartbeat() {
        const heartbeat = {
            timestamp: new Date().toISOString(),
            version: '3.2',
            autoProcessing: state.settings.autoProcessEnabled,
            queueLength: state.queue.length,
            pendingItems: state.queue.filter(q => q.status === 'pending').length
        };
        localStorage.setItem('ccd_sync_hub_heartbeat', JSON.stringify(heartbeat));
        
        // Also write to shared config if connected
        if (isSharedMode) {
            writeSharedHeartbeat();
        }
    }
    
    /**
     * Start heartbeat interval - writes every 60 seconds
     */
    function startHeartbeat() {
        // Write immediately
        writeHeartbeat();
        
        // Then every 60 seconds
        setInterval(writeHeartbeat, 60000);
        
        console.log('[Heartbeat] Started - will update every 60 seconds');
    }
    
    // Write "stopped" heartbeat when page unloads
    window.addEventListener('beforeunload', () => {
        if (isSharedMode && configFileHandle) {
            // Can't use async in beforeunload, but we can try a sync write
            try {
                // Use sendBeacon for reliable delivery (not fully supported for file writes)
                // Fall back to marking heartbeat as stopped in memory
                if (configData) {
                    configData.heartbeat = {
                        ...configData.heartbeat,
                        status: 'stopped',
                        timestamp: new Date().toISOString()
                    };
                }
            } catch (e) {
                console.log('Could not write stopped heartbeat');
            }
        }
    });

    // =============================================
    // MANUAL PULL ORDERS
    // =============================================
    async function pullOrdersFromChannels() {
        const timeRange = document.getElementById('pullTimeRange').value;
        const pullEtsy = document.getElementById('pullEtsy').checked;
        const pullWix = document.getElementById('pullWix').checked;
        const pullWayfair = document.getElementById('pullWayfair').checked;
        
        let startDate, endDate;
        
        if (timeRange === 'custom') {
            startDate = new Date(document.getElementById('pullStartDate').value);
            endDate = new Date(document.getElementById('pullEndDate').value);
        } else {
            const hours = parseInt(timeRange);
            endDate = new Date();
            startDate = new Date(endDate - hours * 60 * 60 * 1000);
        }
        
        // Show loading state
        const resultsDiv = document.getElementById('pullResults');
        const resultsContent = document.getElementById('pullResultsContent');
        resultsDiv.style.display = 'block';
        resultsContent.innerHTML = '<span style="color: var(--info);">‚è≥ Pulling orders...</span>';
        
        const results = {
            etsy: { orders: 0, items: 0, error: null },
            wix: { orders: 0, items: 0, error: null },
            wayfair: { orders: 0, items: 0, error: null }
        };
        
        addLog(`Starting manual pull for ${timeRange === 'custom' ? 'custom range' : 'last ' + timeRange + ' hours'}`, 'info');
        
        // Pull from each channel (respecting toggles)
        if (pullEtsy && state.settings.etsyProxyUrl && isChannelSyncEnabled('etsy')) {
            try {
                const etsyResult = await pullEtsyOrders(startDate, endDate);
                results.etsy = etsyResult;
                addLog(`Etsy: Found ${etsyResult.orders} orders, ${etsyResult.items} items`, etsyResult.orders > 0 ? 'success' : 'info');
            } catch (e) {
                results.etsy.error = e.message;
                addLog(`Etsy pull failed: ${e.message}`, 'error');
            }
        } else if (pullEtsy && !isChannelSyncEnabled('etsy')) {
            results.etsy.error = 'Sync disabled';
            addLog('Etsy: Sync disabled - skipping', 'warning');
        }
        
        if (pullWix && state.settings.wixProxyUrl && isChannelSyncEnabled('wix')) {
            try {
                const wixResult = await pullWixOrders(startDate, endDate);
                results.wix = wixResult;
                addLog(`Wix: Found ${wixResult.orders} orders, ${wixResult.items} items`, wixResult.orders > 0 ? 'success' : 'info');
            } catch (e) {
                results.wix.error = e.message;
                addLog(`Wix pull failed: ${e.message}`, 'error');
            }
        } else if (pullWix && !isChannelSyncEnabled('wix')) {
            results.wix.error = 'Sync disabled';
            addLog('Wix: Sync disabled - skipping', 'warning');
        }
        
        if (pullWayfair && state.settings.wayfairProxyUrl && isChannelSyncEnabled('wayfair')) {
            try {
                const wayfairResult = await pullWayfairOrders(startDate, endDate);
                results.wayfair = wayfairResult;
                addLog(`Wayfair: Found ${wayfairResult.orders} orders, ${wayfairResult.items} items`, wayfairResult.orders > 0 ? 'success' : 'info');
            } catch (e) {
                results.wayfair.error = e.message;
                addLog(`Wayfair pull failed: ${e.message}`, 'error');
            }
        } else if (pullWayfair && !isChannelSyncEnabled('wayfair')) {
            results.wayfair.error = 'Sync disabled';
            addLog('Wayfair: Sync disabled - skipping', 'warning');
        }
        
        // Display results
        const totalOrders = results.etsy.orders + results.wix.orders + results.wayfair.orders;
        const totalItems = results.etsy.items + results.wix.items + results.wayfair.items;
        
        let html = `<strong>Pull Complete</strong><br>`;
        html += `<span style="color: var(--text-dim);">Time range: ${startDate.toLocaleString()} - ${endDate.toLocaleString()}</span><br><br>`;
        
        if (pullEtsy) {
            html += `<span class="queue-channel etsy">ETSY</span> `;
            html += results.etsy.error 
                ? `<span style="color: var(--error);">Error: ${results.etsy.error}</span>`
                : `${results.etsy.orders} orders, ${results.etsy.items} line items`;
            html += '<br>';
        }
        
        if (pullWix) {
            html += `<span class="queue-channel wix">WIX</span> `;
            html += results.wix.error 
                ? `<span style="color: var(--error);">Error: ${results.wix.error}</span>`
                : `${results.wix.orders} orders, ${results.wix.items} line items`;
            html += '<br>';
        }
        
        if (pullWayfair) {
            html += `<span class="queue-channel wayfair">WAYFAIR</span> `;
            html += results.wayfair.error 
                ? `<span style="color: var(--error);">Error: ${results.wayfair.error}</span>`
                : `${results.wayfair.orders} orders, ${results.wayfair.items} line items`;
            html += '<br>';
        }
        
        html += `<br><strong>Total: ${totalOrders} orders, ${totalItems} items</strong>`;
        
        // Add expandable order details
        const detailsHtml = showOrderDetails(results);
        if (detailsHtml) {
            html += `<div style="margin-top: 12px;">
                <button class="btn btn-secondary btn-sm" onclick="this.nextElementSibling.style.display = this.nextElementSibling.style.display === 'none' ? 'block' : 'none'">
                    üìã Show Order Details
                </button>
                <div style="display: none; max-height: 300px; overflow-y: auto;">${detailsHtml}</div>
            </div>`;
        }
        
        resultsContent.innerHTML = html;
        toast(`Pulled ${totalOrders} orders with ${totalItems} items`, totalOrders > 0 ? 'success' : 'info');
        
        // Log to Activity Log
        if (typeof logActivity === 'function' && masterJsonData) {
            logActivity('order', 'order_pull_complete', 'system',
                `Manual pull: ${totalOrders} orders, ${totalItems} items`,
                { 
                    etsy: results.etsy, 
                    wix: results.wix, 
                    wayfair: results.wayfair,
                    totalOrders: totalOrders,
                    totalItems: totalItems,
                    timeRange: timeRange
                }
            );
        }
        
        // Send sync.completed notification
        if (totalOrders > 0) {
            sendEventNotification(
                'sync.completed',
                `Order pull completed: ${totalOrders} orders, ${totalItems} items`,
                {
                    etsy: { orders: results.etsy.orders, items: results.etsy.items },
                    wix: { orders: results.wix.orders, items: results.wix.items },
                    wayfair: { orders: results.wayfair.orders, items: results.wayfair.items },
                    totalOrders: totalOrders,
                    totalItems: totalItems
                }
            );
        }
    }
    
    async function pullEtsyOrders(startDate, endDate) {
        const url = state.settings.etsyProxyUrl;
        const key = state.settings.etsyApiKey || state.settings.ccdApiKey;
        
        console.log('[Etsy Pull] Starting order pull...');
        console.log('[Etsy Pull] URL:', url);
        console.log('[Etsy Pull] Date range:', startDate.toISOString(), 'to', endDate.toISOString());
        
        try {
            // Send ISO date strings - the proxy will convert to Unix timestamps
            const fetchUrl = `${url}?action=getOrders&key=${key}&min_created=${encodeURIComponent(startDate.toISOString())}&max_created=${encodeURIComponent(endDate.toISOString())}&limit=100`;
            console.log('[Etsy Pull] Fetch URL:', fetchUrl.replace(key, 'API_KEY_HIDDEN'));
            
            const response = await fetch(fetchUrl);
            console.log('[Etsy Pull] Response status:', response.status, response.statusText);
            
            // Check for HTTP errors
            if (!response.ok) {
                const errorText = await response.text();
                console.error('[Etsy Pull] HTTP Error:', response.status, errorText);
                throw new Error(`HTTP ${response.status}: ${errorText.substring(0, 200)}`);
            }
            
            const data = await response.json();
            console.log('[Etsy Pull] Response data:', JSON.stringify(data).substring(0, 500));
            
            // Check for API-level errors
            if (data.error) {
                console.error('[Etsy Pull] API Error:', data.error, data.details || '');
                throw new Error(`${data.error}${data.details ? ': ' + data.details : ''}`);
            }
            
            if (!data.success && !data.orders && !data.receipts) {
                console.error('[Etsy Pull] No data returned:', data);
                throw new Error(data.message || 'No orders data returned from Etsy');
            }
            
            const orders = data.orders || data.receipts || [];
            console.log('[Etsy Pull] Orders found:', orders.length);
            
            let itemCount = 0;
            const orderDetails = [];
            
            // Process orders
            for (const order of orders) {
                const items = order.transactions || order.lineItems || [];
                const orderInfo = {
                    id: order.receipt_id || order.id,
                    date: new Date((order.create_timestamp || order.created_timestamp) * 1000).toLocaleString(),
                    buyer: order.buyer_email || order.name || 'Unknown',
                    total: order.grandtotal?.amount || order.total || 0,
                    items: []
                };
                
                for (const item of items) {
                    itemCount++;
                    orderInfo.items.push({
                        sku: item.sku || item.product_data?.sku || 'N/A',
                        title: item.title || item.name || 'Unknown',
                        qty: item.quantity || 1,
                        price: item.price?.amount || item.price || 0
                    });
                }
                orderDetails.push(orderInfo);
            }
            
            console.log('[Etsy Pull] Success - Orders:', orders.length, 'Items:', itemCount);
            return { orders: orders.length, items: itemCount, details: orderDetails };
            
        } catch (e) {
            console.error('[Etsy Pull] Fetch error:', e.message);
            
            // Try JSONP if regular fetch fails (CORS issue)
            try {
                console.log('[Etsy Pull] Trying JSONP fallback...');
                const result = await jsonpRequest(url, {
                    action: 'getOrders',
                    key: key,
                    min_created: startDate.toISOString(),
                    max_created: endDate.toISOString(),
                    limit: '100'
                });
                console.log('[Etsy Pull] JSONP result:', JSON.stringify(result).substring(0, 500));
                
                if (result.error) {
                    throw new Error(`${result.error}${result.details ? ': ' + result.details : ''}`);
                }
                
                const orders = result.orders || result.receipts || [];
                return { orders: orders.length, items: orders.reduce((sum, o) => sum + (o.transactions?.length || 0), 0), details: [] };
            } catch (jsonpError) {
                console.error('[Etsy Pull] JSONP error:', jsonpError.message);
                throw new Error(e.message || jsonpError.message);
            }
        }
    }
    
    async function pullWixOrders(startDate, endDate) {
        const url = state.settings.wixProxyUrl;
        const key = state.settings.ccdApiKey;
        
        const response = await fetch(`${url}?action=getOrders&key=${key}&limit=100`);
        const data = await response.json();
        
        if (!data.success && !data.orders) {
            throw new Error(data.error || 'Failed to get Wix orders');
        }
        
        const allOrders = data.orders || [];
        // Filter by date range
        const orders = allOrders.filter(order => {
            const orderDate = new Date(order.createdDate || order.dateCreated || order._createdDate);
            return orderDate >= startDate && orderDate <= endDate;
        });
        
        let itemCount = 0;
        const orderDetails = [];
        
        for (const order of orders) {
            const items = order.lineItems || [];
            const orderInfo = {
                id: order.number || order.id,
                date: new Date(order.createdDate || order.dateCreated).toLocaleString(),
                buyer: order.billingInfo?.contactDetails?.firstName || order.buyerInfo?.email || 'Unknown',
                total: order.priceSummary?.total?.amount || order.totals?.total || 0,
                items: []
            };
            
            for (const item of items) {
                itemCount++;
                orderInfo.items.push({
                    sku: item.sku || item.catalogReference?.options?.sku || 'N/A',
                    title: item.name || item.productName?.original || 'Unknown',
                    qty: item.quantity || 1,
                    price: item.price?.amount || item.price || 0
                });
            }
            orderDetails.push(orderInfo);
        }
        
        return { orders: orders.length, items: itemCount, details: orderDetails };
    }
    
    async function pullWayfairOrders(startDate, endDate) {
        const url = state.settings.wayfairProxyUrl;
        const key = state.settings.ccdApiKey;
        
        const response = await fetch(`${url}?action=getOrders&key=${key}&limit=100`);
        const data = await response.json();
        
        if (!data.success && !data.orders) {
            throw new Error(data.error || 'Failed to get Wayfair orders');
        }
        
        const allOrders = data.orders || [];
        // Filter by date range
        const orders = allOrders.filter(order => {
            const orderDate = new Date(order.poDate || order.createdDate || order.orderDate);
            return orderDate >= startDate && orderDate <= endDate;
        });
        
        let itemCount = 0;
        const orderDetails = [];
        
        for (const order of orders) {
            const items = order.products || order.lineItems || [];
            const orderInfo = {
                id: order.poNumber || order.id,
                date: new Date(order.poDate || order.createdDate).toLocaleString(),
                buyer: order.shipTo?.name || 'Wayfair Customer',
                total: order.orderTotal || items.reduce((sum, i) => sum + (i.price * i.quantity), 0),
                items: []
            };
            
            for (const item of items) {
                itemCount++;
                orderInfo.items.push({
                    sku: item.supplierPartNumber || item.sku || 'N/A',
                    title: item.name || item.productName || 'Unknown',
                    qty: item.quantity || 1,
                    price: item.price || item.unitPrice || 0
                });
            }
            orderDetails.push(orderInfo);
        }
        
        // Send notification for new Wayfair orders
        if (orders.length > 0) {
            sendEventNotification(
                'wayfair.order',
                `${orders.length} new Wayfair order(s) found with ${itemCount} items`,
                {
                    orderCount: orders.length,
                    itemCount: itemCount,
                    orders: orderDetails.slice(0, 5).map(o => ({
                        id: o.id,
                        buyer: o.buyer,
                        total: o.total,
                        itemCount: o.items.length
                    }))
                }
            );
        }
        
        return { orders: orders.length, items: itemCount, details: orderDetails };
    }
    
    function showOrderDetails(results) {
        let html = '';
        
        ['etsy', 'wix', 'wayfair'].forEach(channel => {
            if (results[channel].details && results[channel].details.length > 0) {
                html += `<div style="margin-top: 12px;"><strong style="color: var(--${channel});">${channel.toUpperCase()} Orders:</strong></div>`;
                results[channel].details.forEach(order => {
                    html += `<div style="margin: 8px 0; padding: 8px; background: var(--bg-dark); border-radius: 4px; font-size: 0.85rem;">`;
                    html += `<div><strong>#${order.id}</strong> - ${order.date}</div>`;
                    html += `<div style="color: var(--text-dim);">${order.buyer}</div>`;
                    order.items.forEach(item => {
                        html += `<div style="margin-left: 12px;">‚Ä¢ ${item.title} (SKU: ${item.sku}) √ó ${item.qty}</div>`;
                    });
                    html += `</div>`;
                });
            }
        });
        
        return html;
    }

    // =============================================
    // QUEUE MANAGEMENT (GAP 1 - v3.1.0)
    // Backward compatible with feature flag: useSharedQueue
    // =============================================
    
    /**
     * Load queue with backward compatibility (GAP 1)
     * Feature Flag: settings.features.useSharedQueue
     */
    async function loadQueue() {
        const config = configData || {};
        const useSharedQueue = config.settings?.features?.useSharedQueue ?? false;
        
        if (useSharedQueue) {
            // NEW: Load from Master JSON _syncQueue
            console.log('[Queue] Using shared queue from Master JSON');
            
            if (!masterJsonData) {
                console.warn('[Queue] Master JSON not loaded, cannot access shared queue');
                state.queue = [];
                return;
            }
            
            // Ensure _syncQueue exists
            if (!masterJsonData._syncQueue) {
                masterJsonData._syncQueue = [];
                console.log('[Queue] Initialized empty _syncQueue in Master JSON');
            }
            
            // Get queue from Master JSON
            state.queue = masterJsonData._syncQueue || [];
            console.log(`[Queue] ‚úÖ Loaded ${state.queue.length} items from Master JSON`);
            
        } else {
            // OLD: Load from localStorage (backward compatible)
            console.log('[Queue] Using legacy localStorage queue');
            const saved = localStorage.getItem('ccd_sync_hub_queue');
            if (saved) {
                try {
                    state.queue = JSON.parse(saved);
                    console.log(`[Queue] ‚úÖ Loaded ${state.queue.length} items from localStorage`);
                } catch (e) {
                    console.error('[Queue] Failed to parse localStorage queue:', e);
                    state.queue = [];
                }
            } else {
                state.queue = [];
            }
        }
    }

    /**
     * Save queue with backward compatibility (GAP 1)
     */
    async function saveQueue() {
        const config = configData || {};
        const useSharedQueue = config.settings?.features?.useSharedQueue ?? false;
        
        if (useSharedQueue) {
            // NEW: Save to Master JSON
            console.log('[Queue] Saving to Master JSON');
            
            if (!masterJsonData) {
                console.error('[Queue] Master JSON not loaded, cannot save shared queue');
                return false;
            }
            
            // Ensure _syncQueue exists
            if (!masterJsonData._syncQueue) {
                masterJsonData._syncQueue = [];
            }
            
            // Update Master JSON
            masterJsonData._syncQueue = state.queue;
            
            // Save file
            try {
                await saveMasterJson({ 
                    actionDescription: `Queue updated: ${state.queue.length} items`,
                    skipLog: true // Don't spam activity log
                });
                console.log('[Queue] ‚úÖ Saved to Master JSON');
                return true;
            } catch (error) {
                console.error('[Queue] Failed to save:', error);
                return false;
            }
            
        } else {
            // OLD: Save to localStorage
            console.log('[Queue] Saving to localStorage');
            localStorage.setItem('ccd_sync_hub_queue', JSON.stringify(state.queue));
            console.log('[Queue] ‚úÖ Saved to localStorage');
            return true;
        }
    }

    /**
     * Add item to queue (GAP 1)
     */
    async function addToQueue(item) {
        // Add to state
        state.queue.push(item);
        
        // Save (uses appropriate method based on feature flag)
        await saveQueue();
        
        // Update UI
        renderQueue();
        updateStats();
        
        console.log('[Queue] Item added:', item.id || item.product?.sku);
    }

    /**
     * Remove item from queue (GAP 1)
     */
    async function removeFromQueue(itemId) {
        // Remove from state
        state.queue = state.queue.filter(item => item.id !== itemId);
        
        // Save
        await saveQueue();
        
        // Update UI
        renderQueue();
        updateStats();
        
        console.log('[Queue] Item removed:', itemId);
    }

    /**
     * Update queue item status (GAP 1)
     */
    async function updateQueueItem(itemId, updates) {
        // Find and update
        const item = state.queue.find(q => q.id === itemId);
        if (item) {
            Object.assign(item, updates);
            
            // Save
            await saveQueue();
            
            // Update UI
            renderQueue();
            updateStats();
            
            console.log('[Queue] Item updated:', itemId);
        }
    }

    function renderQueue() {
        const container = document.getElementById('queueContainer');
        
        if (state.queue.length === 0) {
            container.innerHTML = `
                <div class="empty-state">
                    <div class="empty-state-icon">üì≠</div>
                    <div class="empty-state-title">Queue Empty</div>
                    <div>Add items from Channel Manager to sync</div>
                </div>
            `;
            return;
        }

        container.innerHTML = state.queue.map((item, index) => `
            <div class="queue-item">
                <div class="queue-status ${item.status}"></div>
                <div class="queue-info">
                    <div class="queue-product">
                        ${item.product?.productName || item.product?.name || item.product?.sku || 'Unknown Product'}
                        <span class="action-badge ${item.action || 'update'}">${(item.action || 'update').toUpperCase()}</span>
                    </div>
                    <div class="queue-details">
                        <span class="queue-channel ${item.channel}">${item.channel?.toUpperCase()}</span>
                        SKU: ${item.product?.sku || 'N/A'} ‚Ä¢
                        Action: ${item.action || 'update'} ‚Ä¢
                        Status: ${item.status}
                        ${item.error ? `<br><span style="color: var(--error);">Error: ${item.error}</span>` : ''}
                        ${item.result ? `<br><span style="color: var(--success);">‚úì ${item.result}</span>` : ''}
                    </div>
                </div>
                <div class="queue-actions">
                    ${item.status === 'failed' ? `<button class="btn btn-secondary btn-sm" onclick="retryItem(${index})">üîÑ Retry</button>` : ''}
                    <button class="btn btn-danger btn-sm" onclick="removeItem(${index})">‚úï</button>
                </div>
            </div>
        `).join('');
    }

    function updateStats() {
        const total = state.queue.length;
        const pending = state.queue.filter(i => i.status === 'pending').length;
        const processing = state.queue.filter(i => i.status === 'processing').length;
        const completed = state.queue.filter(i => i.status === 'completed').length;
        const failed = state.queue.filter(i => i.status === 'failed').length;

        document.getElementById('statTotal').textContent = total;
        document.getElementById('statPending').textContent = pending + processing;
        document.getElementById('statCompleted').textContent = completed;
        document.getElementById('statFailed').textContent = failed;
        
        const statusEl = document.getElementById('autoSyncStatus');
        if (state.settings.autoProcessEnabled) {
            statusEl.textContent = 'üîÑ Auto-processing enabled';
            statusEl.style.color = 'var(--success)';
        } else {
            statusEl.textContent = 'Auto-processing disabled';
            statusEl.style.color = 'var(--text-dim)';
        }
    }

    async function clearQueue() {
        if (!confirm('Clear entire queue? This cannot be undone.')) return;
        state.queue = [];
        await saveQueue();
        renderQueue();
        updateStats();
        toast('Queue cleared', 'success');
    }

    async function clearCompletedItems() {
        const before = state.queue.length;
        state.queue = state.queue.filter(i => i.status !== 'completed');
        const removed = before - state.queue.length;
        await saveQueue();
        renderQueue();
        updateStats();
        toast(`Removed ${removed} completed items`, 'success');
    }

    async function removeItem(index) {
        state.queue.splice(index, 1);
        await saveQueue();
        renderQueue();
        updateStats();
    }

    async function retryItem(index) {
        const item = state.queue[index];
        item.status = 'pending';
        item.error = null;
        item.retryCount = (item.retryCount || 0) + 1;
        await saveQueue();
        renderQueue();
        updateStats();
        toast('Item queued for retry', 'info');
    }

    // =============================================
    // QUEUE PROCESSING ENGINE
    // =============================================
    async function processQueue() {
        if (state.processing) {
            toast('Already processing queue', 'warning');
            return;
        }

        const pending = state.queue.filter(i => i.status === 'pending');
        if (pending.length === 0) {
            toast('No pending items to process', 'info');
            return;
        }

        state.processing = true;
        document.getElementById('processBtn').textContent = '‚è∏Ô∏è Processing...';
        document.getElementById('processBtn').disabled = true;

        addLog('Started processing ' + pending.length + ' items', 'info');

        let processed = 0;
        let succeeded = 0;
        let failed = 0;

        for (const item of pending) {
            try {
                item.status = 'processing';
                renderQueue();

                const result = await processQueueItem(item);
                
                if (result.success) {
                    item.status = 'completed';
                    item.result = result.message || 'Success';
                    item.completedAt = new Date().toISOString();
                    
                    // Store returned IDs for future reference
                    if (result.listingId) item.listingId = result.listingId;
                    if (result.productId) item.productId = result.productId;
                    
                    succeeded++;
                    addLog(`‚úì ${item.product?.productName || item.product?.name || 'Item'} ${item.action || 'synced'} to ${item.channel}`, 'success');
                    
                    // Log success to activity log
                    logActivity('sync', 'push_success', item.channel,
                        `Pushed ${item.product?.sku || 'item'} qty=${item.product?.qty} to ${item.channel}`,
                        { sku: item.product?.sku, channel: item.channel, quantity: item.product?.qty, reason: item.reason }
                    );
                } else {
                    throw new Error(result.error || 'Unknown error');
                }
            } catch (error) {
                item.status = 'failed';
                item.error = error.message;
                item.retryCount = (item.retryCount || 0);
                failed++;
                addLog(`‚úó Failed: ${item.product?.productName || item.product?.name || 'Item'} - ${error.message}`, 'error');
                
                // Log failure to activity log
                logActivity('error', 'push_failed', item.channel,
                    `Failed to push ${item.product?.sku || 'item'} to ${item.channel}: ${error.message}`,
                    { sku: item.product?.sku, channel: item.channel, error: error.message, reason: item.reason }
                );
                
                // Auto-retry if enabled and under max retries
                if (state.settings.retryFailedEnabled && item.retryCount < state.settings.maxRetries) {
                    item.status = 'pending';
                    item.retryCount++;
                    addLog(`‚Üª Will retry ${item.product?.productName || item.product?.name || 'Item'} (attempt ${item.retryCount + 1}/${state.settings.maxRetries})`, 'info');
                }
            }

            processed++;
            await saveQueue();
            renderQueue();
            updateStats();

            // Small delay between operations to avoid rate limits
            await sleep(500);
        }

        state.processing = false;
        document.getElementById('processBtn').textContent = '‚ñ∂Ô∏è Process Queue';
        document.getElementById('processBtn').disabled = false;

        addLog(`Completed: ${succeeded} succeeded, ${failed} failed`, succeeded > 0 ? 'success' : 'error');
        toast(`Processed ${processed} items: ${succeeded} succeeded, ${failed} failed`, succeeded > 0 ? 'success' : 'error');
        
        // Log cascade completion to activity log
        if (succeeded > 0 || failed > 0) {
            logActivity('sync', 'cascade_processed', 'system',
                `Cascade sync completed: ${succeeded} succeeded, ${failed} failed`,
                { succeeded: succeeded, failed: failed, total: processed }
            );
            
            // Send sync completed notification
            if (succeeded > 0) {
                sendEventNotification(
                    'channel.sync',
                    `Channel sync completed: ${succeeded} items synced successfully`,
                    {
                        succeeded: succeeded,
                        failed: failed,
                        total: processed
                    }
                );
            }
            
            // Send sync failed notification if there were failures
            if (failed > 0) {
                sendEventNotification(
                    'sync.failed',
                    `Channel sync had ${failed} failures out of ${processed} items`,
                    {
                        succeeded: succeeded,
                        failed: failed,
                        total: processed
                    }
                );
            }
        }
    }

    async function processQueueItem(item) {
        const channel = item.channel;
        const product = item.product;
        const action = item.action || 'update';
        const fields = item.fields || {};

        switch (channel) {
            case 'etsy':
                return await pushToEtsy(product, fields, action);
            case 'wix':
                return await pushToWix(product, fields, action);
            case 'wayfair':
                return await pushToWayfair(product, fields, action);
            default:
                return { success: false, error: 'Unknown channel: ' + channel };
        }
    }

    // =============================================
    // INVENTORY DEDUCTION HELPER (GAP 3 - v3.1.0)
    // Manual deduction helper for special cases
    // Main deduction logic integrated into processOrder()
    // =============================================
    
    /**
     * Deduct inventory for a single SKU (manual deduction helper)
     * Use this for manual adjustments outside of order processing
     */
    async function deductInventory(sku, quantity, reason = 'Manual deduction') {
        if (!masterJsonData) {
            return { success: false, error: 'Master JSON not loaded' };
        }
        
        const product = masterJsonData.inventory.find(p => p.sku === sku);
        if (!product) {
            return { success: false, error: `Product ${sku} not found` };
        }
        
        const oldQty = product.qty || 0;
        const newQty = Math.max(0, oldQty - quantity);
        
        product.qty = newQty;
        
        await saveMasterJson({ 
            actionDescription: `Manual inventory deduction: ${sku} -${quantity}`,
            skipLog: false 
        });
        
        if (typeof logActivity === 'function') {
            logActivity('inventory', 'manual_deduction', 'system',
                `Manually deducted ${quantity} units of ${sku}: ${reason}`,
                { sku: sku, quantity: quantity, oldQty: oldQty, newQty: newQty, reason: reason }
            );
        }
        
        return { 
            success: true, 
            sku: sku, 
            oldQty: oldQty, 
            newQty: newQty, 
            deducted: quantity 
        };
    }

    // =============================================
    // CHANNEL API FUNCTIONS - WITH CREATE SUPPORT
    // =============================================
    
    /**
     * Push to Etsy - handles CREATE, UPDATE, and inventory sync
     * Uses JSONP for GET requests to avoid CORS, POST for mutations
     */
    async function pushToEtsy(product, fields, action) {
        const url = state.settings.etsyProxyUrl;
        const key = state.settings.etsyApiKey || state.settings.ccdApiKey; // Use Etsy key if set
        
        if (!url) return { success: false, error: 'Etsy proxy not configured' };

        try {
            // ============ CREATE NEW LISTING ============
            if (action === 'create') {
                const listingData = {
                    key: key,
                    action: 'createListing',
                    title: (product.productName || product.name || product.sku).substring(0, 140), // Etsy max 140 chars
                    description: product.description || product.productDescription || `${product.productName || product.name} - Quality product from Country Charm Decor`,
                    price: parseFloat(product.retailPrice || product.price || 19.99),
                    quantity: parseInt(product.wixQty || product.qty || product.quantity || 1),
                    sku: product.sku,
                    // Etsy required fields with defaults
                    taxonomy_id: product.taxonomyId || 891, // Home & Living > Home Decor
                    who_made: 'someone_else',
                    when_made: '2020_2024',
                    is_supply: false,
                    shipping_profile_id: product.shippingProfileId || null,
                    tags: product.tags || generateTags(product)
                };

                const result = await etsyPostRequest(url, listingData);
                
                if (result.success) {
                    // Update local product with new listing ID
                    updateProductWithListingId(product.sku, 'etsy', result.listingId);
                    return { 
                        success: true, 
                        message: `Created listing ${result.listingId}`,
                        listingId: result.listingId
                    };
                }
                return result;
            }
            
            // ============ UPDATE EXISTING LISTING ============
            if (action === 'update') {
                // Check what fields to update
                const updateData = {
                    key: key,
                    action: 'updateListing',
                    listing_id: product.etsyListing || product.etsyListingId
                };

                if (!updateData.listing_id) {
                    return { success: false, error: 'No Etsy listing ID - use create action first' };
                }

                // Add fields to update
                if (fields.title || fields.all) updateData.title = (product.productName || product.name).substring(0, 140);
                if (fields.description || fields.all) updateData.description = product.description || product.productDescription;
                if (fields.price || fields.all) updateData.price = parseFloat(product.retailPrice || product.price);
                if (fields.tags || fields.all) updateData.tags = product.tags || generateTags(product);

                const result = await etsyPostRequest(url, updateData);
                
                // Also update inventory if quantity field is set
                if ((fields.quantity || fields.qty || fields.all) && result.success) {
                    await updateEtsyInventory(product, url, key);
                }
                
                return result;
            }

            // ============ INVENTORY ONLY UPDATE ============
            if (fields.quantity || fields.qty) {
                return await updateEtsyInventory(product, url, key);
            }

            return { success: true, message: 'No updates needed' };
        } catch (error) {
            return { success: false, error: error.message };
        }
    }
    
    // Helper for Etsy POST requests (handles CORS via form submission workaround)
    async function etsyPostRequest(url, data) {
        try {
            // Try regular fetch first
            const response = await fetch(url, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(data)
            });
            return await response.json();
        } catch (corsError) {
            // If CORS fails, try with URL params (GET-style POST)
            const params = new URLSearchParams();
            for (const [key, value] of Object.entries(data)) {
                if (Array.isArray(value)) {
                    params.append(key, JSON.stringify(value));
                } else if (value !== null && value !== undefined) {
                    params.append(key, value);
                }
            }
            
            try {
                const result = await jsonpRequest(`${url}?${params.toString()}`);
                return result;
            } catch (jsonpError) {
                return { success: false, error: 'CORS error - ensure proxy allows cross-origin requests' };
            }
        }
    }

    async function updateEtsyInventory(product, url, key) {
        const data = {
            key: key,
            action: 'updateInventory',
            listing_id: product.etsyListing || product.etsyListingId,
            quantity: parseInt(product.wixQty || product.etsyQty || product.quantity || 0),
            sku: product.sku
        };
        return await etsyPostRequest(url, data);
    }

    /**
     * Push to Wix - handles CREATE, UPDATE, and inventory sync
     */
    async function pushToWix(product, fields, action) {
        const url = state.settings.wixProxyUrl;
        const key = state.settings.ccdApiKey;
        
        if (!url) return { success: false, error: 'Wix proxy not configured' };

        try {
            // ============ CREATE NEW PRODUCT ============
            if (action === 'create') {
                const productData = {
                    key: key,
                    action: 'createProduct',
                    name: product.productName || product.name || product.sku,
                    description: product.description || product.productDescription || `${product.productName || product.name} - Quality product from Country Charm Decor`,
                    price: parseFloat(product.retailPrice || product.price || 19.99),
                    sku: product.sku,
                    quantity: parseInt(product.wixQty || product.qty || product.quantity || 1),
                    weight: parseFloat(product.shippingWeight || product.weight || 1),
                    productType: 'physical',
                    visible: true,
                    // Optional fields
                    brand: product.brandName || product.brand || 'Country Charm Decor',
                    ribbon: product.ribbon || ''
                };

                const response = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(productData)
                });

                const result = await response.json();
                
                if (result.success) {
                    // Update local product with new product ID
                    updateProductWithListingId(product.sku, 'wix', result.productId || result.product?.id);
                    return { 
                        success: true, 
                        message: `Created product ${result.productId || result.product?.id}`,
                        productId: result.productId || result.product?.id
                    };
                }
                return result;
            }
            
            // ============ UPDATE EXISTING PRODUCT ============
            if (action === 'update') {
                const updateData = {
                    key: key,
                    action: 'updateProduct',
                    productId: product.wixProductId
                };

                if (!updateData.productId) {
                    return { success: false, error: 'No Wix product ID - use create action first' };
                }

                // Add fields to update
                if (fields.title || fields.name || fields.all) updateData.name = product.productName || product.name;
                if (fields.description || fields.all) updateData.description = product.description || product.productDescription;
                if (fields.price || fields.all) updateData.price = parseFloat(product.retailPrice || product.price);

                const response = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(updateData)
                });

                const result = await response.json();
                
                // Also update inventory if quantity field is set
                if ((fields.quantity || fields.qty || fields.all) && result.success) {
                    await updateWixInventory(product, url, key);
                }
                
                return result;
            }

            // ============ INVENTORY ONLY UPDATE ============
            if (fields.quantity || fields.qty) {
                return await updateWixInventory(product, url, key);
            }

            return { success: true, message: 'No updates needed' };
        } catch (error) {
            return { success: false, error: error.message };
        }
    }

    async function updateWixInventory(product, url, key) {
        const response = await fetch(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                key: key,
                action: 'updateInventory',
                productId: product.wixProductId,
                sku: product.sku,
                quantity: parseInt(product.wixQty || product.quantity || 0)
            })
        });
        return await response.json();
    }

    /**
     * Push to Wayfair - handles UPDATE and inventory sync
     * NOTE: Wayfair product creation requires a separate onboarding process
     */
    async function pushToWayfair(product, fields, action) {
        const url = state.settings.wayfairProxyUrl;
        const key = state.settings.ccdApiKey;
        
        if (!url) return { success: false, error: 'Wayfair proxy not configured' };

        try {
            // ============ CREATE - NOT SUPPORTED VIA API ============
            if (action === 'create') {
                return { 
                    success: false, 
                    error: 'Wayfair product creation requires their supplier portal onboarding process. Use Wayfair Partner Home to add new products.' 
                };
            }
            
            // ============ UPDATE / INVENTORY SYNC ============
            if (fields.quantity || fields.qty || action === 'update') {
                const response = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        key: key,
                        action: 'updateInventory',
                        inventory: [{
                            supplierPartNumber: product.wayfairSku || product.sku,
                            quantityOnHand: parseInt(product.wayfairQty || product.qty || product.quantity || 0),
                            supplierId: 254744
                        }],
                        feedKind: 'DIFFERENTIAL'
                    })
                });

                const result = await response.json();
                return result;
            }

            return { success: true, message: 'No updates needed' };
        } catch (error) {
            return { success: false, error: error.message };
        }
    }

    // =============================================
    // HELPER FUNCTIONS
    // =============================================
    
    /**
     * Generate tags from product data
     */
    function generateTags(product) {
        const tags = [];
        
        // Add brand
        if (product.brandName || product.brand) {
            tags.push(product.brandName || product.brand);
        }
        
        // Add words from product name
        const name = product.productName || product.name || '';
        const words = name.split(/\s+/).filter(w => w.length > 3);
        tags.push(...words.slice(0, 5));
        
        // Add default tags
        tags.push('home decor', 'country charm', 'rustic');
        
        // Return unique tags, max 13 (Etsy limit)
        return [...new Set(tags)].slice(0, 13);
    }

    /**
     * Update product with new listing/product ID
     * Saves back to localStorage for persistence
     */
    function updateProductWithListingId(sku, channel, id) {
        try {
            const inventoryData = localStorage.getItem('ccdInventory') || localStorage.getItem('ccdInventoryData');
            if (!inventoryData) return;
            
            const inventory = JSON.parse(inventoryData);
            const product = inventory.find(p => p.sku === sku);
            
            if (product) {
                if (channel === 'etsy') {
                    product.etsyListingId = id;
                } else if (channel === 'wix') {
                    product.wixProductId = id;
                }
                
                // Save back
                localStorage.setItem('ccdInventoryData', JSON.stringify(inventory));
                addLog(`Updated ${sku} with ${channel} ID: ${id}`, 'info');
            }
        } catch (e) {
            console.error('Error updating product ID:', e);
        }
    }

    // =============================================
    // CONNECTION TESTING
    // =============================================
    /**
     * Auto-test all connections on startup (silent - no toasts)
     */
    async function autoTestAllConnections() {
        console.log('[Init] Auto-testing all connections...');
        
        // Test each channel in parallel
        const tests = [];
        
        if (state.settings.etsyProxyUrl) {
            tests.push(testEtsy().catch(e => console.log('[AutoTest] Etsy failed:', e.message)));
        }
        if (state.settings.wixProxyUrl) {
            tests.push(testWix().catch(e => console.log('[AutoTest] Wix failed:', e.message)));
        }
        if (state.settings.wayfairProxyUrl) {
            tests.push(testWayfair().catch(e => console.log('[AutoTest] Wayfair failed:', e.message)));
        }
        if (state.settings.shippoProxyUrl) {
            tests.push(testShippo().catch(e => console.log('[AutoTest] Shippo failed:', e.message)));
        }
        if (state.settings.syncHubProxyUrl) {
            tests.push(testSyncHubFromSettings().catch(e => console.log('[AutoTest] Sync Hub failed:', e.message)));
        }
        
        await Promise.allSettled(tests);
        console.log('[Init] Connection tests complete');
    }

    async function testAllConnections() {
        toast('Testing all connections...', 'info');
        await testEtsy();
        await testWix();
        await testWayfair();
        await testShippo();
        await testSyncHubFromSettings();
    }

    async function testEtsy() {
        const url = state.settings.etsyProxyUrl;
        const key = state.settings.etsyApiKey || state.settings.ccdApiKey; // Use Etsy key if set, else fall back
        
        if (!url) {
            updateConnectionStatus('etsy', false, 'Not configured');
            return;
        }

        // Use JSONP to avoid CORS issues with Etsy proxy
        try {
            const result = await jsonpRequest(`${url}?action=status&key=${key}`);
            state.connections.etsy = result.success;
            updateConnectionStatus('etsy', result.success, result.success ? 'Connected' : result.error);
            
            // Send notification on connection failure
            if (!result.success) {
                sendEventNotification(
                    'connection.error',
                    `Etsy API connection failed: ${result.error || 'Unknown error'}`,
                    { channel: 'etsy', error: result.error }
                );
            }
        } catch (error) {
            // Fallback to regular fetch
            try {
                const response = await fetch(`${url}?action=status&key=${key}`);
                const result = await response.json();
                state.connections.etsy = result.success;
                updateConnectionStatus('etsy', result.success, result.success ? 'Connected' : result.error);
                
                if (!result.success) {
                    sendEventNotification(
                        'connection.error',
                        `Etsy API connection failed: ${result.error || 'Unknown error'}`,
                        { channel: 'etsy', error: result.error }
                    );
                }
            } catch (fetchError) {
                state.connections.etsy = false;
                updateConnectionStatus('etsy', false, 'CORS error - check proxy deployment');
                
                sendEventNotification(
                    'connection.error',
                    `Etsy API connection failed: CORS error`,
                    { channel: 'etsy', error: 'CORS error - check proxy deployment' }
                );
            }
        }
    }
    
    // JSONP helper for proxies that don't support CORS
    // Supports both: jsonpRequest(fullUrl) and jsonpRequest(baseUrl, {params})
    function jsonpRequest(url, params = null) {
        return new Promise((resolve, reject) => {
            const callbackName = 'jsonp_callback_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            const script = document.createElement('script');
            
            // Set timeout
            const timeout = setTimeout(() => {
                cleanup();
                reject(new Error('JSONP request timeout'));
            }, 30000);
            
            // Cleanup function
            function cleanup() {
                clearTimeout(timeout);
                delete window[callbackName];
                if (script.parentNode) script.parentNode.removeChild(script);
            }
            
            // Define callback
            window[callbackName] = function(data) {
                cleanup();
                resolve(data);
            };
            
            // Build final URL
            let finalUrl = url;
            if (params && typeof params === 'object' && Object.keys(params).length > 0) {
                const queryString = Object.entries(params)
                    .map(([key, value]) => `${encodeURIComponent(key)}=${encodeURIComponent(value)}`)
                    .join('&');
                finalUrl += (url.includes('?') ? '&' : '?') + queryString;
            }
            
            // Add callback
            const separator = finalUrl.includes('?') ? '&' : '?';
            script.src = `${finalUrl}${separator}callback=${callbackName}`;
            script.onerror = () => {
                cleanup();
                reject(new Error('JSONP request failed'));
            };
            
            document.head.appendChild(script);
        });
    }

    async function testWix() {
        const url = state.settings.wixProxyUrl;
        const key = state.settings.ccdApiKey;
        
        if (!url) {
            updateConnectionStatus('wix', false, 'Not configured');
            return;
        }

        try {
            const response = await fetch(`${url}?action=status&key=${key}`);
            const result = await response.json();
            
            state.connections.wix = result.success;
            updateConnectionStatus('wix', result.success, result.success ? 'Connected' : result.error);
            
            if (!result.success) {
                sendEventNotification(
                    'connection.error',
                    `Wix API connection failed: ${result.error || 'Unknown error'}`,
                    { channel: 'wix', error: result.error }
                );
            }
        } catch (error) {
            state.connections.wix = false;
            updateConnectionStatus('wix', false, error.message);
            
            sendEventNotification(
                'connection.error',
                `Wix API connection failed: ${error.message}`,
                { channel: 'wix', error: error.message }
            );
        }
    }

    async function testWayfair() {
        const url = state.settings.wayfairProxyUrl;
        const key = state.settings.ccdApiKey;
        
        if (!url) {
            updateConnectionStatus('wayfair', false, 'Not configured');
            return;
        }

        try {
            const response = await fetch(`${url}?action=status&key=${key}`);
            const result = await response.json();
            
            state.connections.wayfair = result.success;
            updateConnectionStatus('wayfair', result.success, result.success ? 'Connected' : result.error);
            
            if (!result.success) {
                sendEventNotification(
                    'connection.error',
                    `Wayfair API connection failed: ${result.error || 'Unknown error'}`,
                    { channel: 'wayfair', error: result.error }
                );
            }
        } catch (error) {
            state.connections.wayfair = false;
            updateConnectionStatus('wayfair', false, error.message);
            
            sendEventNotification(
                'connection.error',
                `Wayfair API connection failed: ${error.message}`,
                { channel: 'wayfair', error: error.message }
            );
        }
    }

    async function testShippo() {
        const url = state.settings.shippoProxyUrl;
        const key = state.settings.ccdApiKey;
        
        if (!url) {
            updateConnectionStatus('shippo', false, 'Not configured');
            return;
        }

        try {
            const response = await fetch(`${url}?action=status&key=${key}`);
            const result = await response.json();
            
            state.connections.shippo = result.success;
            updateConnectionStatus('shippo', result.success, result.success ? 'Connected' : result.error);
        } catch (error) {
            state.connections.shippo = false;
            updateConnectionStatus('shippo', false, error.message);
        }
    }

    async function testSyncHubFromSettings() {
        const url = document.getElementById('syncHubProxyUrlSettings').value || state.settings.syncHubProxyUrl;
        const key = state.settings.ccdApiKey;
        
        if (!url) {
            updateConnectionStatus('syncHubConn', false, 'Not configured');
            return;
        }

        try {
            // Try fetch first (works better from file:// protocol)
            let data;
            try {
                const fetchUrl = `${url}?action=ping&key=${key}`;
                const response = await fetch(fetchUrl);
                data = await response.json();
            } catch (fetchError) {
                // Fall back to JSONP if fetch fails
                console.log('Fetch failed, trying JSONP:', fetchError.message);
                data = await jsonpRequest(url, { action: 'ping' });
            }
            
            if (data.success || data.pong) {
                state.connections.syncHub = true;
                updateConnectionStatus('syncHubConn', true, `Connected (v${data.version || 'unknown'})`);
                
                // Sync both URL fields
                state.settings.syncHubProxyUrl = url;
                document.getElementById('syncHubProxyUrl').value = url;
                toast('Sync Hub connected!', 'success');
            } else {
                state.connections.syncHub = false;
                updateConnectionStatus('syncHubConn', false, data.error || 'Connection failed');
            }
        } catch (error) {
            state.connections.syncHub = false;
            updateConnectionStatus('syncHubConn', false, error.message);
        }
    }

    function updateConnectionStatus(channel, connected, message) {
        const statusEl = document.getElementById(channel + 'Status');
        if (statusEl) {
            const dotClass = connected ? 'connected' : 'disconnected';
            statusEl.innerHTML = `<span class="connection-dot ${dotClass}"></span>${message}`;
        }
    }

    // =============================================
    // AUTO-PROCESSING
    // =============================================
    function startAutoProcess() {
        if (state.autoProcessInterval) {
            clearInterval(state.autoProcessInterval);
        }
        
        state.autoProcessInterval = setInterval(() => {
            const pending = state.queue.filter(i => i.status === 'pending');
            if (pending.length > 0 && !state.processing) {
                addLog('Auto-processing ' + pending.length + ' pending items', 'info');
                processQueue();
            }
        }, 5 * 60 * 1000); // Every 5 minutes
        
        updateStats();
    }

    function stopAutoProcess() {
        if (state.autoProcessInterval) {
            clearInterval(state.autoProcessInterval);
            state.autoProcessInterval = null;
        }
        updateStats();
    }

    // =============================================
    // ACTIVITY LOG
    // =============================================
    function loadLog() {
        const saved = localStorage.getItem('ccd_sync_hub_log');
        if (saved) {
            try {
                state.activityLog = JSON.parse(saved);
            } catch (e) {
                state.activityLog = [];
            }
        }
    }

    function saveLog() {
        // Keep only last 500 entries
        if (state.activityLog.length > 500) {
            state.activityLog = state.activityLog.slice(-500);
        }
        localStorage.setItem('ccd_sync_hub_log', JSON.stringify(state.activityLog));
    }

    function addLog(message, type = 'info') {
        state.activityLog.push({
            timestamp: new Date().toISOString(),
            message: message,
            type: type
        });
        saveLog();
        renderLog();
    }

    function renderLog() {
        const container = document.getElementById('activityLog');
        
        if (state.activityLog.length === 0) {
            container.innerHTML = `
                <div class="empty-state">
                    <div class="empty-state-icon">üìù</div>
                    <div class="empty-state-title">No Activity</div>
                    <div>Activity log is empty</div>
                </div>
            `;
            return;
        }

        // Show most recent first
        const reversed = [...state.activityLog].reverse();
        container.innerHTML = reversed.slice(0, 100).map(entry => `
            <div class="log-entry">
                <div class="log-time">${new Date(entry.timestamp).toLocaleString()}</div>
                <div class="log-message log-${entry.type}">${entry.message}</div>
            </div>
        `).join('');
    }

    function clearLog() {
        if (!confirm('Clear activity log?')) return;
        state.activityLog = [];
        saveLog();
        renderLog();
        toast('Log cleared', 'success');
    }

    // =============================================
    // SETTINGS
    // =============================================
    function loadSettings() {
        // If in shared mode, settings are already loaded from config
        if (isSharedMode) {
            applySettingsFromConfig();
            return;
        }
        
        // Otherwise load from localStorage
        loadSettingsFromLocalStorage();
    }

    async function saveSettings() {
        state.settings.ccdApiKey = document.getElementById('ccdApiKey').value;
        state.settings.etsyApiKey = document.getElementById('etsyApiKey').value;
        state.settings.etsyProxyUrl = document.getElementById('etsyProxyUrl').value;
        state.settings.wixProxyUrl = document.getElementById('wixProxyUrl').value;
        state.settings.wayfairProxyUrl = document.getElementById('wayfairProxyUrl').value;
        state.settings.shippoProxyUrl = document.getElementById('shippoProxyUrl').value;
        
        // Sync Hub URL - get from Settings field and sync to Notifications field
        const syncHubUrl = document.getElementById('syncHubProxyUrlSettings').value;
        state.settings.syncHubProxyUrl = syncHubUrl;
        document.getElementById('syncHubProxyUrl').value = syncHubUrl;
        
        state.settings.autoProcessEnabled = document.getElementById('autoProcessEnabled').checked;
        state.settings.retryFailedEnabled = document.getElementById('retryFailedEnabled').checked;
        
        // Channel sync toggles
        state.settings.enableEtsySync = document.getElementById('enableEtsySync').checked;
        state.settings.enableWixSync = document.getElementById('enableWixSync').checked;
        state.settings.enableWayfairSync = document.getElementById('enableWayfairSync').checked;

        // Save to shared config if connected, otherwise localStorage
        if (isSharedMode && configData) {
            configData.settings = {
                ...configData.settings,
                ccdApiKey: state.settings.ccdApiKey,
                etsyApiKey: state.settings.etsyApiKey,
                shippoApiKey: state.settings.shippoApiKey || '',
                wayfairApiKey: state.settings.wayfairApiKey || '',
                syncHubApiKey: state.settings.syncHubApiKey || '',
                proxyUrls: {
                    etsy: state.settings.etsyProxyUrl,
                    wix: state.settings.wixProxyUrl,
                    wayfair: state.settings.wayfairProxyUrl,
                    syncHub: state.settings.syncHubProxyUrl,
                    shippo: state.settings.shippoProxyUrl
                },
                autoProcessEnabled: state.settings.autoProcessEnabled,
                retryFailedEnabled: state.settings.retryFailedEnabled,
                maxRetries: state.settings.maxRetries,
                // Channel sync toggles
                enableEtsySync: state.settings.enableEtsySync,
                enableWixSync: state.settings.enableWixSync,
                enableWayfairSync: state.settings.enableWayfairSync
            };
            
            await saveConfigFile({ actionDescription: 'Settings updated' });
            addLog('Settings saved to shared config', 'success');
        } else {
            localStorage.setItem('ccd_sync_hub_settings', JSON.stringify(state.settings));
        }

        if (state.settings.autoProcessEnabled) {
            startAutoProcess();
            updateNextRunTime();
        } else {
            stopAutoProcess();
        }

        toast('Settings saved', 'success');
    }

    /**
     * Update channel toggle status display
     */
    function updateChannelToggleStatus(channel) {
        const checkbox = document.getElementById('enable' + channel.charAt(0).toUpperCase() + channel.slice(1) + 'Sync');
        const statusSpan = document.getElementById(channel + 'SyncStatus');
        
        if (checkbox && statusSpan) {
            const enabled = checkbox.checked;
            statusSpan.textContent = enabled ? 'ENABLED' : 'DISABLED';
            statusSpan.className = 'channel-toggle-status ' + (enabled ? 'enabled' : 'disabled');
            
            // Update state
            state.settings['enable' + channel.charAt(0).toUpperCase() + channel.slice(1) + 'Sync'] = enabled;
            
            // Auto-save settings
            saveSettings();
            
            addLog(`${channel.toUpperCase()} sync ${enabled ? 'enabled' : 'disabled'}`, enabled ? 'success' : 'warning');
        }
    }
    
    /**
     * Load channel toggle states into UI
     */
    function loadChannelToggles() {
        const channels = ['etsy', 'wix', 'wayfair'];
        channels.forEach(channel => {
            const checkbox = document.getElementById('enable' + channel.charAt(0).toUpperCase() + channel.slice(1) + 'Sync');
            const statusSpan = document.getElementById(channel + 'SyncStatus');
            const settingKey = 'enable' + channel.charAt(0).toUpperCase() + channel.slice(1) + 'Sync';
            
            if (checkbox && statusSpan) {
                const enabled = state.settings[settingKey] !== false; // Default to true
                checkbox.checked = enabled;
                statusSpan.textContent = enabled ? 'ENABLED' : 'DISABLED';
                statusSpan.className = 'channel-toggle-status ' + (enabled ? 'enabled' : 'disabled');
            }
        });
    }
    
    /**
     * Check if a channel sync is enabled
     */
    function isChannelSyncEnabled(channel) {
        const settingKey = 'enable' + channel.charAt(0).toUpperCase() + channel.slice(1) + 'Sync';
        return state.settings[settingKey] !== false; // Default to true
    }

    function resetSettings() {
        if (!confirm('Reset to default settings?')) return;
        localStorage.removeItem('ccd_sync_hub_settings');
        location.reload();
    }

    // =============================================
    // UI FUNCTIONS
    // =============================================
    function toggleGroup(groupName) {
        const group = document.getElementById('group-' + groupName);
        if (group) {
            group.classList.toggle('collapsed');
        }
    }

    function switchView(viewName) {
        document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
        document.querySelectorAll('.nav-btn').forEach(b => b.classList.remove('active'));
        
        const view = document.getElementById(viewName + 'View');
        const btn = document.querySelector(`[data-view="${viewName}"]`);
        if (view) view.classList.add('active');
        if (btn) btn.classList.add('active');
    }

    function refreshData() {
        loadQueue();
        renderQueue();
        updateStats();
        renderLog();
        toast('Refreshed', 'success');
    }

    function toast(message, type = 'info') {
        const container = document.getElementById('toastContainer');
        if (!container) {
            console.log('[Toast]', type, message);
            return;
        }
        const toastEl = document.createElement('div');
        toastEl.className = `toast ${type}`;
        toastEl.textContent = message;
        container.appendChild(toastEl);
        
        setTimeout(() => {
            if (toastEl.parentNode) toastEl.remove();
        }, 5000);
    }

    function sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    // =============================================
    // NOTIFICATION FUNCTIONS
    // =============================================
    function getSyncHubUrl() {
        return document.getElementById('syncHubProxyUrl').value || state.settings.syncHubProxyUrl;
    }

    function getSyncHubApiKey() {
        return state.settings.ccdApiKey;
    }

    async function testSyncHubConnection() {
        const url = getSyncHubUrl();
        const statusDiv = document.getElementById('syncHubStatus');
        
        if (!url) {
            statusDiv.innerHTML = '<span style="color: var(--error);">‚ùå Please enter the Sync Hub Proxy URL</span>';
            toast('Please enter Sync Hub URL', 'error');
            return;
        }
        
        statusDiv.innerHTML = '<span style="color: var(--info);">‚è≥ Testing connection...</span>';
        
        try {
            const data = await fetchOrJsonp(url, { action: 'ping' });
            
            if (data.success || data.pong) {
                statusDiv.innerHTML = `
                    <span style="color: var(--success);">‚úÖ Connected to Sync Hub v${data.version || 'unknown'}</span><br>
                    <span style="color: var(--text-dim); font-size: 0.8rem;">Last ping: ${new Date().toLocaleString()}</span>
                `;
                toast('Sync Hub connected!', 'success');
                
                // Save the URL if connection successful
                state.settings.syncHubProxyUrl = url;
                localStorage.setItem('ccd_sync_hub_settings', JSON.stringify(state.settings));
            } else {
                statusDiv.innerHTML = `<span style="color: var(--error);">‚ùå ${data.error || 'Unknown error'}</span>`;
                toast('Connection failed', 'error');
            }
        } catch (error) {
            statusDiv.innerHTML = `<span style="color: var(--error);">‚ùå Connection failed: ${error.message}</span>`;
            toast('Connection failed: ' + error.message, 'error');
        }
    }

    async function loadNotificationSettings() {
        const url = getSyncHubUrl();
        const apiKey = getSyncHubApiKey();
        
        if (!url) {
            toast('Please enter Sync Hub URL first', 'error');
            return;
        }
        if (!apiKey) {
            toast('Please enter API Key in Settings first', 'error');
            return;
        }
        
        toast('Loading settings...', 'info');
        
        try {
            const data = await fetchOrJsonp(url, { action: 'settings', key: apiKey });
            
            if (data.success) {
                const settings = data.settings;
                
                // Update form fields
                document.getElementById('emailEnabled').checked = settings.emailEnabled;
                
                // Handle email addresses
                if (settings.emailAddresses && settings.emailAddresses.length > 0) {
                    document.getElementById('emailAddresses').value = settings.emailAddresses.join(', ');
                } else if (settings.emailAddress) {
                    document.getElementById('emailAddresses').value = settings.emailAddress;
                }
                
                document.getElementById('digestFrequency').value = settings.digestFrequency || 'daily';
                document.getElementById('digestHour').value = settings.digestHour || 8;
                
                // Update notification preferences
                const eventNotifications = settings.eventNotifications || {};
                for (const [eventType, notifySetting] of Object.entries(eventNotifications)) {
                    const select = document.getElementById(`notify_${eventType}`);
                    if (select) {
                        select.value = notifySetting;
                    }
                }
                
                toast('Settings loaded successfully', 'success');
                addLog('Loaded notification settings from Sync Hub', 'success');
            } else {
                toast(`Failed to load settings: ${data.error}`, 'error');
            }
        } catch (error) {
            console.log('[Notifications] Proxy load failed, trying localStorage:', error.message);
            
            // Fallback to localStorage (v3.2.1 fix)
            if (state.settings.emailAddresses) {
                document.getElementById('emailAddresses').value = state.settings.emailAddresses;
                document.getElementById('emailEnabled').checked = state.settings.emailEnabled || false;
                toast('Loaded settings from local storage', 'info');
            } else {
                toast(`Error loading settings: ${error.message}`, 'error');
            }
        }
    }

    async function saveNotificationSettings() {
        const url = getSyncHubUrl();
        const apiKey = getSyncHubApiKey();
        
        // ALWAYS save locally first (v3.2.2 fix)
        const emailAddresses = document.getElementById('emailAddresses').value;
        const emailEnabled = document.getElementById('emailEnabled').checked;
        const digestFrequency = document.getElementById('digestFrequency').value;
        const digestHour = document.getElementById('digestHour').value;
        
        // Collect event notification preferences
        const eventNotifications = {};
        document.querySelectorAll('[id^="notify_"]').forEach(select => {
            const eventType = select.id.replace('notify_', '');
            eventNotifications[eventType] = select.value;
        });
        
        // Save to localStorage FIRST (always works)
        state.settings.emailAddresses = emailAddresses;
        state.settings.emailEnabled = emailEnabled;
        state.settings.digestFrequency = digestFrequency;
        state.settings.digestHour = digestHour;
        state.settings.eventNotifications = eventNotifications;
        
        if (url) {
            state.settings.syncHubProxyUrl = url;
        }
        
        localStorage.setItem('ccd_sync_hub_settings', JSON.stringify(state.settings));
        
        console.log('[Notifications] Saved to localStorage:', {
            emailAddresses: emailAddresses,
            emailEnabled: emailEnabled
        });
        
        // If URL and API key available, also try to sync to proxy (optional)
        if (!url || !apiKey) {
            toast('Settings saved locally (Sync Hub URL not configured)', 'success');
            return;
        }
        
        toast('Saving to Sync Hub...', 'info');
        
        const params = {
            action: 'updateSettings',
            key: apiKey,
            emailEnabled: emailEnabled.toString(),
            emailAddresses: emailAddresses,
            digestFrequency: digestFrequency,
            digestHour: digestHour,
            eventNotifications: JSON.stringify(eventNotifications)
        };
        };
        
        try {
            const data = await fetchOrJsonp(url, params);
            
            if (data.success) {
                toast('Settings saved to Sync Hub', 'success');
                addLog('Saved notification settings to Sync Hub', 'success');
            } else {
                toast(`Settings saved locally (Sync Hub sync failed: ${data.error})`, 'warning');
                addLog('Settings saved locally only - Sync Hub failed', 'warning');
            }
        } catch (error) {
            console.error('[Notifications] Sync Hub save failed:', error);
            toast('Settings saved locally (Sync Hub unavailable)', 'warning');
            addLog('Settings saved locally only - Sync Hub unavailable', 'warning');
        }
    }

    /**
     * Helper: Try fetch first, fall back to JSONP (for Sync Hub proxy)
     */
    async function fetchOrJsonp(url, params = {}) {
        // Try fetch first
        try {
            const queryString = Object.entries(params)
                .map(([key, value]) => `${encodeURIComponent(key)}=${encodeURIComponent(value)}`)
                .join('&');
            const fetchUrl = url + (url.includes('?') ? '&' : '?') + queryString;
            const response = await fetch(fetchUrl);
            return await response.json();
        } catch (fetchError) {
            // Fall back to JSONP
            console.log('Fetch failed, trying JSONP:', fetchError.message);
            return await jsonpRequest(url, params);
        }
    }

    async function sendTestEvent() {
        const url = getSyncHubUrl();
        const apiKey = getSyncHubApiKey();
        
        if (!url) {
            toast('Please enter Sync Hub URL first', 'error');
            return;
        }
        
        toast('Sending test event...', 'info');
        
        try {
            const data = await fetchOrJsonp(url, {
                action: 'test',
                key: apiKey,
                message: 'Test event from Sync Hub v3.9'
            });
            
            if (data.success) {
                const eventId = data.eventId || 'unknown';
                toast(`Test event sent! ID: ${eventId}`, 'success');
                addLog(`Sent test event to Sync Hub (ID: ${eventId})`, 'success');
                viewSyncHubEvents(); // Refresh event list
            } else {
                toast(`Failed: ${data.error}`, 'error');
            }
        } catch (error) {
            toast(`Error: ${error.message}`, 'error');
        }
    }

    async function sendDigestNow() {
        const url = getSyncHubUrl();
        const apiKey = getSyncHubApiKey();
        
        if (!url) {
            toast('Please enter Sync Hub URL first', 'error');
            return;
        }
        
        toast('Sending digest...', 'info');
        
        try {
            const data = await fetchOrJsonp(url, { action: 'sendDigest', key: apiKey });
            
            if (data.success) {
                const msg = data.message || `Digest sent with ${data.sent || 0} events`;
                toast(msg, 'success');
                addLog('Sent digest email from Sync Hub', 'success');
            } else {
                toast(`${data.error || 'Unknown error'}`, 'error');
            }
        } catch (error) {
            toast(`Error: ${error.message}`, 'error');
        }
    }

    async function sendTestEmail() {
        const url = getSyncHubUrl();
        const apiKey = getSyncHubApiKey();
        
        if (!url) {
            toast('Please enter Sync Hub URL first', 'error');
            return;
        }
        
        toast('Sending test email...', 'info');
        
        try {
            const data = await fetchOrJsonp(url, { action: 'sendTestEmail', key: apiKey });
            
            if (data.success) {
                toast(`Test email sent to ${data.sentTo}`, 'success');
                addLog(`Sent test email to ${data.sentTo}`, 'success');
            } else {
                toast(`Failed: ${data.error}`, 'error');
            }
        } catch (error) {
            toast(`Error: ${error.message}`, 'error');
        }
    }

    async function viewSyncHubEvents() {
        const url = getSyncHubUrl();
        const apiKey = getSyncHubApiKey();
        
        if (!url) {
            toast('Please enter Sync Hub URL first', 'error');
            return;
        }
        
        toast('Loading events...', 'info');
        
        try {
            const data = await fetchOrJsonp(url, { action: 'events', key: apiKey, limit: '50' });
            
            if (data.success) {
                const logDiv = document.getElementById('syncHubEventLog');
                const events = data.events || [];
                
                if (events.length === 0) {
                    logDiv.innerHTML = `
                        <div class="empty-state" style="padding: 30px;">
                            <div class="empty-state-icon">üìã</div>
                            <div class="empty-state-title">No Events</div>
                            <div>No events logged yet</div>
                        </div>
                    `;
                } else {
                    logDiv.innerHTML = events.map(event => `
                        <div class="log-entry">
                            <div class="log-time">${new Date(event.timestamp).toLocaleString()}</div>
                            <div class="log-message">
                                <span style="color: ${getEventTypeColor(event.eventType)}; font-weight: 600;">${event.eventType || 'unknown'}</span>
                                <span style="color: var(--text-muted);"> from ${(event.source || 'unknown').toUpperCase()}</span>
                                ${event.message ? `<br><span style="color: var(--text-dim);">${event.message}</span>` : ''}
                            </div>
                        </div>
                    `).join('');
                }
                
                const loadedCount = data.returned ?? events.length;
                const totalCount = data.total ?? events.length;
                toast(`Loaded ${loadedCount} of ${totalCount} events`, 'success');
            } else {
                toast(`${data.error || 'Unknown error'}`, 'error');
            }
        } catch (error) {
            toast(`Error: ${error.message}`, 'error');
        }
    }

    function getEventTypeColor(eventType) {
        if (!eventType) return 'var(--text-dim)';
        if (eventType.includes('failed') || eventType.includes('error') || eventType.includes('critical')) return 'var(--error)';
        if (eventType.includes('conflict')) return '#fd7e14';
        if (eventType.includes('par') || eventType.includes('low') || eventType.includes('reorder')) return 'var(--warning)';
        if (eventType.includes('soldout')) return '#6c757d';
        if (eventType.includes('order') || eventType.includes('sold') || eventType.includes('sale')) return 'var(--success)';
        if (eventType.includes('wayfair')) return 'var(--wayfair)';
        if (eventType.includes('sync') || eventType.includes('channel')) return 'var(--info)';
        if (eventType === 'test') return 'var(--success)';
        return 'var(--text-dim)';
    }

    async function clearSyncHubEvents() {
        if (!confirm('Are you sure you want to clear ALL events from Sync Hub? This cannot be undone.')) {
            return;
        }
        
        const url = getSyncHubUrl();
        const apiKey = getSyncHubApiKey();
        
        if (!url) {
            toast('Please enter Sync Hub URL first', 'error');
            return;
        }
        
        toast('Clearing events...', 'info');
        
        try {
            const data = await fetchOrJsonp(url, { action: 'clearEvents', key: apiKey, confirm: 'true' });
            
            if (data.success) {
                toast(`Cleared ${data.cleared || 0} events`, 'success');
                addLog(`Cleared ${data.cleared || 0} events from Sync Hub`, 'info');
                viewSyncHubEvents(); // Refresh
            } else {
                toast(`${data.error}`, 'error');
            }
        } catch (error) {
            toast(`Error: ${error.message}`, 'error');
        }
    }

    // =============================================
    // MASTER JSON FILE FUNCTIONS
    // =============================================
    
    /**
     * Select and load Master JSON file using File System Access API
     */
    async function selectMasterJsonFile() {
        try {
            // Check if File System Access API is supported
            if (!('showOpenFilePicker' in window)) {
                toast('File System Access API not supported. Please use Chrome or Edge.', 'error');
                addLog('File System Access API not supported in this browser', 'error');
                return;
            }
            
            const options = {
                types: [{
                    description: 'JSON Files',
                    accept: { 'application/json': ['.json'] }
                }],
                multiple: false
            };
            
            const [fileHandle] = await window.showOpenFilePicker(options);
            masterJsonFileHandle = fileHandle;
            
            // Save to IndexedDB for persistence
            try {
                await saveFileHandle('masterJson', fileHandle);
                console.log('[Master JSON] File handle saved to IndexedDB');
            } catch (e) {
                console.warn('[Master JSON] Could not save file handle:', e);
            }
            
            // Hide reconnect banner if shown
            const banner = document.getElementById('masterJsonReconnectBanner');
            if (banner) banner.style.display = 'none';
            
            await loadMasterJson();
            
        } catch (error) {
            if (error.name === 'AbortError') {
                // User cancelled - not an error
                return;
            }
            console.error('[Master JSON] Select error:', error);
            toast(`Error selecting file: ${error.message}`, 'error');
            logError(`Master JSON select: ${error.message}`);
        }
    }
    
    /**
     * Load/reload Master JSON from the selected file handle
     */
    async function loadMasterJson() {
        if (!masterJsonFileHandle) {
            toast('No file selected. Click "Select File" first.', 'warning');
            return;
        }
        
        try {
            const file = await masterJsonFileHandle.getFile();
            const contents = await file.text();
            
            masterJsonData = JSON.parse(contents);
            
            // COLLISION DETECTION: Store file timestamp and metadata version
            loadedFileTimestamp = file.lastModified;
            loadedMetadataVersion = masterJsonData._metadata?.version || 0;
            
            // Update state
            state.masterJson.fileName = file.name;
            state.masterJson.lastLoaded = new Date().toISOString();
            state.connections.masterJson = true;
            
            // Analyze the data
            analyzeMasterJson();
            
            // ====== GAP 9: LOAD PROCESSED ORDER IDS ======
            loadProcessedOrderIds();
            
            // Update UI
            updateMasterJsonUI();
            
            toast(`Loaded ${state.masterJson.productCount} products from ${file.name}`, 'success');
            addLog(`Master JSON loaded: ${file.name} (${state.masterJson.productCount} products)`, 'success');
            
            // Log to Activity Log
            if (typeof logActivity === 'function') {
                logActivity('system', 'file_connected', 'system',
                    `Sync Hub connected to Master JSON: ${state.masterJson.productCount} items`,
                    { filename: file.name, itemCount: state.masterJson.productCount, source: 'sync_hub' }
                );
            }
            
        } catch (error) {
            console.error('[Master JSON] Load error:', error);
            state.connections.masterJson = false;
            updateMasterJsonUI();
            toast(`Error loading file: ${error.message}`, 'error');
            logError(`Master JSON load: ${error.message}`);
        }
    }
    
    /**
     * Analyze Master JSON data structure and count linkages
     */
    function analyzeMasterJson() {
        if (!masterJsonData) return;
        
        // Handle different possible structures
        let products = [];
        if (Array.isArray(masterJsonData)) {
            products = masterJsonData;
        } else if (masterJsonData.products && Array.isArray(masterJsonData.products)) {
            products = masterJsonData.products;
        } else if (masterJsonData.inventory && Array.isArray(masterJsonData.inventory)) {
            products = masterJsonData.inventory;
        } else if (masterJsonData.items && Array.isArray(masterJsonData.items)) {
            products = masterJsonData.items;
        } else {
            // Try to find any array in the object
            for (const key in masterJsonData) {
                if (Array.isArray(masterJsonData[key]) && masterJsonData[key].length > 0) {
                    products = masterJsonData[key];
                    break;
                }
            }
        }
        
        state.masterJson.productCount = products.length;
        state.masterJson.etsyLinked = 0;
        state.masterJson.wixLinked = 0;
        state.masterJson.wayfairLinked = 0;
        
        for (const product of products) {
            // Check for Etsy linkage
            if (product.etsyListing || product.etsyListingId || product.etsy_listing_id) {
                state.masterJson.etsyLinked++;
            }
            // Check for Wix linkage
            if (product.wixProductId || product.wix_product_id || product.wixId) {
                state.masterJson.wixLinked++;
            }
            // Check for Wayfair linkage
            if (product.wayfairSku || product.supplierPartNumber || product.wayfair_sku) {
                state.masterJson.wayfairLinked++;
            }
        }
    }
    
    /**
     * Update Master JSON UI elements
     */
    function updateMasterJsonUI() {
        const connected = state.connections.masterJson;
        
        // Update connection banner visibility
        const connectionBanner = document.getElementById('masterJsonConnectionBanner');
        if (connectionBanner) {
            connectionBanner.style.display = connected ? 'none' : 'block';
        }
        
        // Update file name and details
        const fileNameEl = document.getElementById('masterJsonFileName');
        const detailsEl = document.getElementById('masterJsonDetails');
        const iconEl = document.getElementById('masterJsonIcon');
        const dotEl = document.getElementById('masterJsonConnectionDot');
        const statsEl = document.getElementById('masterJsonStats');
        const connStatusEl = document.getElementById('masterJsonConnStatus');
        
        if (fileNameEl) {
            fileNameEl.textContent = connected ? state.masterJson.fileName : 'No file selected';
        }
        
        if (detailsEl) {
            if (connected) {
                const lastLoaded = state.masterJson.lastLoaded ? new Date(state.masterJson.lastLoaded).toLocaleString() : 'Unknown';
                detailsEl.textContent = `Last loaded: ${lastLoaded}`;
            } else {
                detailsEl.textContent = 'Click "Select File" to connect to your master inventory';
            }
        }
        
        if (iconEl) {
            iconEl.textContent = connected ? '‚úÖ' : 'üìÑ';
        }
        
        if (dotEl) {
            dotEl.className = connected ? 'connection-dot connected' : 'connection-dot disconnected';
        }
        
        if (connStatusEl) {
            connStatusEl.innerHTML = connected 
                ? `<span class="connection-dot connected"></span>Connected (${state.masterJson.productCount} products)`
                : `<span class="connection-dot disconnected"></span>Not connected`;
        }
        
        // Show/hide stats
        if (statsEl) {
            statsEl.style.display = connected ? 'block' : 'none';
        }
        
        // Update stats values
        if (connected) {
            const setEl = (id, val) => {
                const el = document.getElementById(id);
                if (el) el.textContent = val;
            };
            setEl('masterJsonProductCount', state.masterJson.productCount);
            setEl('masterJsonEtsyLinked', state.masterJson.etsyLinked);
            setEl('masterJsonWixLinked', state.masterJson.wixLinked);
            setEl('masterJsonWayfairLinked', state.masterJson.wayfairLinked);
        }
        
        // Enable/disable buttons
        const btnView = document.getElementById('btnViewProducts');
        const btnExport = document.getElementById('btnExportJson');
        const btnValidate = document.getElementById('btnValidateJson');
        
        if (btnView) btnView.disabled = !connected;
        if (btnExport) btnExport.disabled = !connected;
        if (btnValidate) btnValidate.disabled = !connected;
    }
    
    /**
     * View products in a modal/expandable section
     */
    function viewMasterJsonProducts() {
        if (!masterJsonData) {
            toast('No data loaded', 'warning');
            return;
        }
        
        // Get products array
        let products = [];
        if (Array.isArray(masterJsonData)) {
            products = masterJsonData;
        } else if (masterJsonData.products) {
            products = masterJsonData.products;
        } else if (masterJsonData.inventory) {
            products = masterJsonData.inventory;
        } else if (masterJsonData.items) {
            products = masterJsonData.items;
        }
        
        // Create a simple modal to display products
        const modal = document.createElement('div');
        modal.style.cssText = `
            position: fixed; top: 0; left: 0; right: 0; bottom: 0; 
            background: rgba(0,0,0,0.8); z-index: 3000; 
            display: flex; align-items: center; justify-content: center;
            padding: 20px;
        `;
        
        const content = document.createElement('div');
        content.style.cssText = `
            background: var(--bg-card); border-radius: 12px; 
            max-width: 900px; width: 100%; max-height: 80vh; 
            overflow: hidden; display: flex; flex-direction: column;
        `;
        
        content.innerHTML = `
            <div style="padding: 20px; border-bottom: 1px solid var(--border); display: flex; justify-content: space-between; align-items: center;">
                <h3 style="margin: 0;">üì¶ Master Inventory (${products.length} products)</h3>
                <button class="btn btn-secondary" onclick="this.closest('div').parentElement.parentElement.remove()">‚úï Close</button>
            </div>
            <div style="padding: 20px; overflow-y: auto; flex: 1;">
                <table style="width: 100%; border-collapse: collapse; font-size: 0.85rem;">
                    <thead>
                        <tr style="background: var(--bg-input);">
                            <th style="padding: 10px; text-align: left; border-bottom: 1px solid var(--border);">SKU</th>
                            <th style="padding: 10px; text-align: left; border-bottom: 1px solid var(--border);">Name</th>
                            <th style="padding: 10px; text-align: center; border-bottom: 1px solid var(--border);">Qty</th>
                            <th style="padding: 10px; text-align: center; border-bottom: 1px solid var(--border);">Etsy</th>
                            <th style="padding: 10px; text-align: center; border-bottom: 1px solid var(--border);">Wix</th>
                            <th style="padding: 10px; text-align: center; border-bottom: 1px solid var(--border);">Wayfair</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${products.slice(0, 100).map(p => `
                            <tr style="border-bottom: 1px solid var(--border);">
                                <td style="padding: 8px;">${p.sku || p.SKU || 'N/A'}</td>
                                <td style="padding: 8px;">${(p.productName || p.name || p.title || 'Unknown').substring(0, 40)}...</td>
                                <td style="padding: 8px; text-align: center;">${p.warehouseQty || p.qty || p.quantity || 0}</td>
                                <td style="padding: 8px; text-align: center;">${(p.etsyListing || p.etsyListingId) ? '‚úÖ' : '‚ùå'}</td>
                                <td style="padding: 8px; text-align: center;">${(p.wixProductId || p.wixId) ? '‚úÖ' : '‚ùå'}</td>
                                <td style="padding: 8px; text-align: center;">${(p.wayfairSku || p.supplierPartNumber) ? '‚úÖ' : '‚ùå'}</td>
                            </tr>
                        `).join('')}
                        ${products.length > 100 ? `<tr><td colspan="6" style="padding: 10px; text-align: center; color: var(--text-dim);">... and ${products.length - 100} more products</td></tr>` : ''}
                    </tbody>
                </table>
            </div>
        `;
        
        modal.appendChild(content);
        document.body.appendChild(modal);
        
        // Close on backdrop click
        modal.addEventListener('click', (e) => {
            if (e.target === modal) modal.remove();
        });
    }
    
    /**
     * Export Master JSON as backup
     */
    async function exportMasterJson() {
        if (!masterJsonData) {
            toast('No data to export', 'warning');
            return;
        }
        
        try {
            const timestamp = new Date().toISOString().split('T')[0];
            const fileName = `master-inventory-backup-${timestamp}.json`;
            
            const blob = new Blob([JSON.stringify(masterJsonData, null, 2)], { type: 'application/json' });
            
            if ('showSaveFilePicker' in window) {
                const handle = await window.showSaveFilePicker({
                    suggestedName: fileName,
                    types: [{ description: 'JSON', accept: { 'application/json': ['.json'] } }]
                });
                const writable = await handle.createWritable();
                await writable.write(blob);
                await writable.close();
                toast(`Backup saved as ${handle.name}`, 'success');
            } else {
                // Fallback for browsers without File System Access API
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = fileName;
                a.click();
                URL.revokeObjectURL(url);
                toast('Backup downloaded', 'success');
            }
            
            addLog(`Exported Master JSON backup: ${fileName}`, 'success');
            
        } catch (error) {
            if (error.name !== 'AbortError') {
                toast(`Export failed: ${error.message}`, 'error');
                logError(`Export Master JSON: ${error.message}`);
            }
        }
    }
    
    /**
     * Validate Master JSON data for common issues
     */
    function validateMasterJson() {
        if (!masterJsonData) {
            toast('No data to validate', 'warning');
            return;
        }
        
        const issues = [];
        let products = [];
        
        // Get products array
        if (Array.isArray(masterJsonData)) {
            products = masterJsonData;
        } else if (masterJsonData.products) {
            products = masterJsonData.products;
        } else if (masterJsonData.inventory) {
            products = masterJsonData.inventory;
        } else if (masterJsonData.items) {
            products = masterJsonData.items;
        }
        
        const skus = new Set();
        let duplicateSkus = 0;
        let missingSku = 0;
        let negativeQty = 0;
        let noChannelLinks = 0;
        
        for (let i = 0; i < products.length; i++) {
            const p = products[i];
            const sku = p.sku || p.SKU;
            
            // Check for missing SKU
            if (!sku) {
                missingSku++;
                issues.push(`Row ${i + 1}: Missing SKU`);
            } else if (skus.has(sku)) {
                duplicateSkus++;
                issues.push(`Row ${i + 1}: Duplicate SKU "${sku}"`);
            } else {
                skus.add(sku);
            }
            
            // Check for negative quantity
            const qty = p.warehouseQty || p.qty || p.quantity || 0;
            if (qty < 0) {
                negativeQty++;
                issues.push(`${sku || 'Row ' + (i+1)}: Negative quantity (${qty})`);
            }
            
            // Check for no channel links
            const hasEtsy = p.etsyListing || p.etsyListingId;
            const hasWix = p.wixProductId || p.wixId;
            const hasWayfair = p.wayfairSku || p.supplierPartNumber;
            if (!hasEtsy && !hasWix && !hasWayfair) {
                noChannelLinks++;
            }
        }
        
        // Show results
        let message = `Validation Complete\n\n`;
        message += `‚úÖ Total Products: ${products.length}\n`;
        message += `${missingSku > 0 ? '‚ùå' : '‚úÖ'} Missing SKUs: ${missingSku}\n`;
        message += `${duplicateSkus > 0 ? '‚ùå' : '‚úÖ'} Duplicate SKUs: ${duplicateSkus}\n`;
        message += `${negativeQty > 0 ? '‚ö†Ô∏è' : '‚úÖ'} Negative Quantities: ${negativeQty}\n`;
        message += `${noChannelLinks > 0 ? '‚ö†Ô∏è' : '‚úÖ'} Products with no channel links: ${noChannelLinks}\n`;
        
        if (issues.length > 0) {
            message += `\nFirst 10 issues:\n${issues.slice(0, 10).join('\n')}`;
        }
        
        alert(message);
        
        const status = (missingSku + duplicateSkus) > 0 ? 'warning' : 'success';
        toast(`Validation: ${issues.length} issues found`, status);
        addLog(`Master JSON validated: ${issues.length} issues`, status);
    }
    
    /**
     * Save changes back to Master JSON file
     */
    async function saveMasterJson(options = {}) {
        const { isAutoProcess = false, actionDescription = 'Manual save', changes = [] } = options;
        
        if (!masterJsonFileHandle || !masterJsonData) {
            toast('No file connected', 'error');
            return false;
        }
        
        try {
            // ============================================================
            // COLLISION DETECTION - Check before saving
            // ============================================================
            const collisionCheck = await checkForCollision();
            
            if (collisionCheck.collision) {
                if (isAutoProcess) {
                    // AUTO-PROCESS: Silent reload and return for retry
                    console.log('[Collision] Detected during auto-process, reloading...');
                    addLog('‚ö†Ô∏è Collision detected during auto-process - reloading file', 'warning');
                    
                    // Reload fresh data
                    await loadMasterJson();
                    
                    // Signal caller to retry with fresh data
                    return { saved: false, reason: 'collision_reload' };
                    
                } else {
                    // MANUAL: Show dialog
                    const action = await showCollisionDialog(collisionCheck);
                    
                    if (action === 'reload') {
                        await loadMasterJson();
                        toast('üîÑ File reloaded - please re-apply your changes', 'info');
                        return false;
                    } else if (action === 'cancel') {
                        return false;
                    }
                    // action === 'overwrite' - continue with save
                }
            }
            
            // ============================================================
            // Update metadata
            // ============================================================
            masterJsonData._metadata = masterJsonData._metadata || {};
            masterJsonData._metadata.version = (masterJsonData._metadata.version || 0) + 1;
            masterJsonData._metadata.lastModified = new Date().toISOString();
            masterJsonData._metadata.lastModifiedBy = getAppIdentifier();
            masterJsonData._metadata.lastAction = actionDescription;
            
            // Add changes to change log
            masterJsonData._changeLog = masterJsonData._changeLog || [];
            if (changes && changes.length > 0) {
                changes.forEach(change => {
                    masterJsonData._changeLog.unshift(createChangeLogEntry(change));
                });
            }
            
            // Prune old change log entries
            pruneChangeLog(masterJsonData);
            
            // ============================================================
            // Save to file
            // ============================================================
            const writable = await masterJsonFileHandle.createWritable();
            await writable.write(JSON.stringify(masterJsonData, null, 2));
            await writable.close();
            
            // ============================================================
            // COLLISION DETECTION - Update tracking variables after save
            // ============================================================
            const newFile = await masterJsonFileHandle.getFile();
            loadedFileTimestamp = newFile.lastModified;
            loadedMetadataVersion = masterJsonData._metadata.version;
            
            if (!isAutoProcess) {
                toast('Master JSON saved', 'success');
            }
            addLog('Master JSON file saved', 'success');
            
            // Log to Activity Log
            if (typeof logActivity === 'function') {
                logActivity('system', 'file_saved', 'system',
                    `Sync Hub saved Master JSON: ${actionDescription}`,
                    { action: actionDescription, changesCount: changes?.length || 0, source: 'sync_hub' }
                );
            }
            
            return true;
            
        } catch (error) {
            console.error('[Master JSON] Save error:', error);
            toast(`Save failed: ${error.message}`, 'error');
            logError(`Master JSON save: ${error.message}`);
            
            // Send critical error notification
            sendEventNotification(
                'cloud.save.failed',
                `Failed to save Master JSON: ${error.message}`,
                {
                    error: error.message,
                    timestamp: new Date().toISOString()
                }
            );
            
            return false;
        }
    }
    
    /**
     * Update a product in the Master JSON by SKU
     */
    function updateMasterJsonProduct(sku, updates) {
        if (!masterJsonData) return false;
        
        let products = [];
        if (Array.isArray(masterJsonData)) {
            products = masterJsonData;
        } else if (masterJsonData.products) {
            products = masterJsonData.products;
        } else if (masterJsonData.inventory) {
            products = masterJsonData.inventory;
        } else if (masterJsonData.items) {
            products = masterJsonData.items;
        }
        
        const product = products.find(p => (p.sku || p.SKU) === sku);
        if (product) {
            Object.assign(product, updates);
            return true;
        }
        return false;
    }
    
    /**
     * Get a product from Master JSON by SKU
     */
    function getMasterJsonProduct(sku) {
        if (!masterJsonData) return null;
        
        let products = [];
        if (Array.isArray(masterJsonData)) {
            products = masterJsonData;
        } else if (masterJsonData.products) {
            products = masterJsonData.products;
        } else if (masterJsonData.inventory) {
            products = masterJsonData.inventory;
        } else if (masterJsonData.items) {
            products = masterJsonData.items;
        }
        
        return products.find(p => (p.sku || p.SKU) === sku) || null;
    }

    // =============================================
    // ORDERS MANAGEMENT FUNCTIONS
    // =============================================
    
    /**
     * Switch between order tabs
     */
    function switchOrdersTab(tab) {
        state.currentOrdersTab = tab;
        
        // Update tab buttons
        ['all', 'etsy', 'wix', 'wayfair', 'lowstock'].forEach(t => {
            const btn = document.getElementById('ordersTab' + t.charAt(0).toUpperCase() + t.slice(1));
            if (btn) {
                btn.className = t === tab ? 'btn btn-sm' : 'btn btn-sm btn-secondary';
                if (t === tab) btn.style.background = 'var(--bg-hover)';
            }
        });
        
        renderOrders();
    }
    
    /**
     * Fetch orders from all channels
     */
    async function fetchAllOrders() {
        addLog('Fetching orders from all channels...', 'info');
        toast('Fetching orders...', 'info');
        
        const endDate = new Date();
        const startDate = new Date(endDate - 24 * 60 * 60 * 1000); // Last 24 hours
        
        // Reset orders
        state.orders.etsy = [];
        state.orders.wix = [];
        state.orders.wayfair = [];
        state.orders.all = [];
        
        // Fetch from each channel in parallel (respecting toggles)
        const promises = [];
        
        if (state.settings.etsyProxyUrl && isChannelSyncEnabled('etsy')) {
            promises.push(fetchEtsyOrdersForView(startDate, endDate));
        }
        if (state.settings.wixProxyUrl && isChannelSyncEnabled('wix')) {
            promises.push(fetchWixOrdersForView(startDate, endDate));
        }
        if (state.settings.wayfairProxyUrl && isChannelSyncEnabled('wayfair')) {
            promises.push(fetchWayfairOrdersForView(startDate, endDate));
        }
        
        await Promise.allSettled(promises);
        
        // Combine all orders
        state.orders.all = [
            ...state.orders.etsy,
            ...state.orders.wix,
            ...state.orders.wayfair
        ].sort((a, b) => new Date(b.date) - new Date(a.date));
        
        // ============================================================
        // SAVE ORDERS TO SYNC DATA FILE (v3.9)
        // ============================================================
        await saveSyncDataFile();
        
        // Check for low stock
        checkLowStock();
        
        // Update UI
        updateOrderStats();
        renderOrders();
        
        toast(`Found ${state.orders.all.length} orders`, 'success');
        addLog(`Orders fetched: Etsy(${state.orders.etsy.length}), Wix(${state.orders.wix.length}), Wayfair(${state.orders.wayfair.length})`, 'success');
        
        // Log new (unprocessed) orders to activity log
        const newOrders = state.orders.all.filter(o => !o.processed);
        for (const order of newOrders) {
            const itemCount = order.items?.length || 0;
            const totalValue = parseFloat(order.total) || 0;
            logActivity('order', 'order_received', order.channel,
                `Order ${order.id} received - ${itemCount} item${itemCount !== 1 ? 's' : ''}, $${totalValue.toFixed(2)}`,
                { 
                    orderId: order.id, 
                    channel: order.channel,
                    items: order.items?.map(i => ({ sku: i.sku, qty: i.qty, price: i.price })),
                    total: totalValue,
                    buyer: order.buyer
                }
            );
        }
    }
    
    /**
     * Fetch Etsy orders for Orders view
     */
    async function fetchEtsyOrdersForView(startDate, endDate) {
        try {
            const url = state.settings.etsyProxyUrl;
            const key = state.settings.etsyApiKey || state.settings.ccdApiKey;
            
            const response = await fetch(`${url}?action=getOrders&key=${key}&min_created=${encodeURIComponent(startDate.toISOString())}&max_created=${encodeURIComponent(endDate.toISOString())}&limit=100`);
            const data = await response.json();
            
            if (data.error) throw new Error(data.error);
            
            const orders = data.orders || data.receipts || [];
            
            state.orders.etsy = orders.map(order => ({
                id: 'ETSY-' + (order.receipt_id || order.id),
                channel: 'etsy',
                date: new Date((order.create_timestamp || order.created_timestamp) * 1000).toISOString(),
                buyer: order.buyer_email || order.name || 'Unknown',
                total: (order.grandtotal?.amount || order.total || 0) / 100, // Etsy returns cents
                status: order.status || 'pending',
                processed: state.orders.processedIds.has('ETSY-' + (order.receipt_id || order.id)),
                items: (order.transactions || order.lineItems || []).map(item => ({
                    sku: item.sku || item.product_data?.sku || 'UNKNOWN',
                    title: item.title || item.name || 'Unknown Item',
                    qty: item.quantity || 1,
                    price: (item.price?.amount || item.price || 0) / 100
                }))
            }));
            
        } catch (error) {
            console.error('[Etsy Orders] Error:', error);
            addLog(`Etsy orders error: ${error.message}`, 'error');
        }
    }
    
    /**
     * Fetch Wix orders for Orders view
     */
    async function fetchWixOrdersForView(startDate, endDate) {
        try {
            const url = state.settings.wixProxyUrl;
            const key = state.settings.ccdApiKey;
            
            const response = await fetch(`${url}?action=getOrders&key=${key}&limit=100`);
            const data = await response.json();
            
            if (data.error) throw new Error(data.error);
            
            const orders = data.orders || [];
            
            state.orders.wix = orders.map(order => ({
                id: 'WIX-' + (order.id || order.number),
                channel: 'wix',
                date: order.createdDate || order.dateCreated || new Date().toISOString(),
                buyer: order.buyerInfo?.email || order.billingInfo?.email || 'Unknown',
                total: order.totals?.total || order.total || 0,
                status: order.fulfillmentStatus || order.status || 'pending',
                processed: state.orders.processedIds.has('WIX-' + (order.id || order.number)),
                items: (order.lineItems || []).map(item => ({
                    sku: item.sku || item.productId || 'UNKNOWN',
                    title: item.name || item.productName || 'Unknown Item',
                    qty: item.quantity || 1,
                    price: item.price || item.priceData?.price || 0
                }))
            }));
            
        } catch (error) {
            console.error('[Wix Orders] Error:', error);
            addLog(`Wix orders error: ${error.message}`, 'error');
        }
    }
    
    /**
     * Fetch Wayfair orders for Orders view
     */
    async function fetchWayfairOrdersForView(startDate, endDate) {
        try {
            const url = state.settings.wayfairProxyUrl;
            const key = state.settings.ccdApiKey;
            
            const response = await fetch(`${url}?action=getOrders&key=${key}&limit=100`);
            const data = await response.json();
            
            if (data.error) throw new Error(data.error);
            
            const orders = data.orders || data.purchaseOrders || [];
            
            state.orders.wayfair = orders.map(order => ({
                id: 'WF-' + (order.poNumber || order.id),
                channel: 'wayfair',
                date: order.poDate || order.orderDate || new Date().toISOString(),
                buyer: 'Wayfair Customer',
                total: order.total || 0,
                status: order.status || 'pending',
                processed: state.orders.processedIds.has('WF-' + (order.poNumber || order.id)),
                items: (order.products || order.lineItems || []).map(item => ({
                    sku: item.supplierPartNumber || item.sku || 'UNKNOWN',
                    title: item.name || item.productName || 'Unknown Item',
                    qty: item.quantity || 1,
                    price: item.price || item.wholesalePrice || 0
                }))
            }));
            
        } catch (error) {
            console.error('[Wayfair Orders] Error:', error);
            addLog(`Wayfair orders error: ${error.message}`, 'error');
        }
    }
    
    /**
     * Update order statistics
     */
    function updateOrderStats() {
        const etsyPending = state.orders.etsy.filter(o => !o.processed).length;
        const wixPending = state.orders.wix.filter(o => !o.processed).length;
        const wayfairPending = state.orders.wayfair.filter(o => !o.processed).length;
        
        document.getElementById('etsyOrderCount').textContent = etsyPending;
        document.getElementById('wixOrderCount').textContent = wixPending;
        document.getElementById('wayfairOrderCount').textContent = wayfairPending;
        document.getElementById('lowStockCount').textContent = state.lowStockItems.length;
    }
    
    /**
     * Render orders list based on current tab
     */
    function renderOrders() {
        const container = document.getElementById('ordersList');
        const emptyState = document.getElementById('ordersEmptyState');
        
        let orders = [];
        
        if (state.currentOrdersTab === 'lowstock') {
            renderLowStock();
            container.style.display = 'none';
            emptyState.style.display = 'none';
            return;
        }
        
        switch (state.currentOrdersTab) {
            case 'etsy': orders = state.orders.etsy; break;
            case 'wix': orders = state.orders.wix; break;
            case 'wayfair': orders = state.orders.wayfair; break;
            default: orders = state.orders.all;
        }
        
        if (orders.length === 0) {
            container.style.display = 'none';
            emptyState.style.display = 'flex';
            document.getElementById('lowStockPanel').style.display = 'none';
            return;
        }
        
        container.style.display = 'block';
        emptyState.style.display = 'none';
        document.getElementById('lowStockPanel').style.display = 'none';
        
        container.innerHTML = orders.map(order => `
            <div class="order-item ${order.processed ? 'processed' : ''}" data-order-id="${order.id}">
                <div class="order-header">
                    <div>
                        <span class="order-id">${order.id}</span>
                        <span class="order-channel ${order.channel}">${order.channel.toUpperCase()}</span>
                        ${order.processed ? '<span style="color: var(--success); margin-left: 8px;">‚úÖ Processed</span>' : ''}
                    </div>
                    <span style="font-weight: 600; color: var(--success);">$${(parseFloat(order.total) || 0).toFixed(2)}</span>
                </div>
                <div class="order-meta">
                    <span>üìÖ ${new Date(order.date).toLocaleString()}</span>
                    <span>üë§ ${order.buyer}</span>
                    <span>üì¶ ${order.items.length} item(s)</span>
                </div>
                <div class="order-items">
                    ${order.items.map(item => `
                        <div class="order-line">
                            <div>
                                <span>${item.title.substring(0, 50)}${item.title.length > 50 ? '...' : ''}</span>
                                <span class="order-line-sku">${item.sku}</span>
                            </div>
                            <div>
                                <span class="order-line-qty">√ó${item.qty}</span>
                                <span style="margin-left: 12px;">$${(parseFloat(item.price) || 0).toFixed(2)}</span>
                            </div>
                        </div>
                    `).join('')}
                </div>
                ${!order.processed ? `
                    <div class="order-actions">
                        <button class="btn btn-sm btn-success" onclick="processOrder('${order.id}')">‚úÖ Process & Deduct Inventory</button>
                        <button class="btn btn-sm btn-secondary" onclick="markOrderProcessed('${order.id}')">üè∑Ô∏è Mark Processed (No Deduct)</button>
                    </div>
                ` : ''}
            </div>
        `).join('');
    }
    
    /**
     * Check for low stock items
     */
    function checkLowStock() {
        state.lowStockItems = [];
        
        if (!masterJsonData) return;
        
        const products = getProductsArray();
        
        for (const product of products) {
            const qty = product.warehouseQty || product.qty || product.quantity || 0;
            const parLevel = product.parLevel || product.par || 0;
            
            if (parLevel > 0 && qty < parLevel) {
                state.lowStockItems.push({
                    sku: product.sku || product.SKU,
                    name: product.productName || product.name || 'Unknown',
                    currentQty: qty,
                    parLevel: parLevel,
                    deficit: parLevel - qty
                });
            }
        }
        
        // Sort by deficit (most urgent first)
        state.lowStockItems.sort((a, b) => b.deficit - a.deficit);
        
        // Update stats
        document.getElementById('lowStockCount').textContent = state.lowStockItems.length;
        
        // Show alert if there are low stock items
        if (state.lowStockItems.length > 0) {
            addLog(`‚ö†Ô∏è ${state.lowStockItems.length} items below PAR level`, 'warning');
            
            // Log low stock alert to activity log (only log critical items - top 5)
            const criticalItems = state.lowStockItems.slice(0, 5);
            logActivity('inventory', 'par_triggered', 'system',
                `${state.lowStockItems.length} items below PAR level`,
                { 
                    count: state.lowStockItems.length,
                    criticalItems: criticalItems.map(i => ({ sku: i.sku, current: i.currentQty, par: i.parLevel, deficit: i.deficit }))
                }
            );
            
            // Send low stock notification (only once per session to avoid spam)
            if (!state.lowStockNotificationSent) {
                sendEventNotification(
                    'low.stock',
                    `${state.lowStockItems.length} items below PAR level`,
                    {
                        count: state.lowStockItems.length,
                        topItems: criticalItems.map(i => ({
                            sku: i.sku,
                            name: i.name,
                            current: i.currentQty,
                            par: i.parLevel,
                            deficit: i.deficit
                        }))
                    }
                );
                state.lowStockNotificationSent = true;
            }
        }
    }
    
    /**
     * Render low stock panel
     */
    function renderLowStock() {
        const panel = document.getElementById('lowStockPanel');
        const list = document.getElementById('lowStockList');
        
        if (state.lowStockItems.length === 0) {
            panel.style.display = 'none';
            document.getElementById('ordersEmptyState').innerHTML = `
                <div class="empty-state-icon">‚úÖ</div>
                <div class="empty-state-title">All Stock Levels OK</div>
                <div>No items are currently below their PAR level</div>
            `;
            document.getElementById('ordersEmptyState').style.display = 'flex';
            document.getElementById('ordersList').style.display = 'none';
            return;
        }
        
        panel.style.display = 'block';
        document.getElementById('ordersEmptyState').style.display = 'none';
        document.getElementById('ordersList').style.display = 'none';
        
        list.innerHTML = state.lowStockItems.map(item => `
            <div class="lowstock-item">
                <div>
                    <div class="lowstock-sku">${item.sku}</div>
                    <div class="lowstock-name">${item.name}</div>
                </div>
                <div class="lowstock-qty">
                    <span class="lowstock-current">${item.currentQty}</span>
                    <span class="lowstock-par">PAR: ${item.parLevel}</span>
                    <span style="color: var(--error);">(-${item.deficit})</span>
                </div>
            </div>
        `).join('');
    }
    
    /**
     * Get products array from Master JSON (helper)
     */
    function getProductsArray() {
        if (!masterJsonData) return [];
        
        if (Array.isArray(masterJsonData)) return masterJsonData;
        if (masterJsonData.products) return masterJsonData.products;
        if (masterJsonData.inventory) return masterJsonData.inventory;
        if (masterJsonData.items) return masterJsonData.items;
        
        return [];
    }
    
    // ============================================================================
    // CHANNEL ALLOCATION AUTO-ADJUSTMENT (v2.1.0)
    // Ensures channel allocations stay valid after order processing
    // Rules:
    // - Etsy = Wix always (they sync together)
    // - Online channels (Etsy, Wix, Wayfair) cannot exceed Warehouse Qty
    // - TreasureMarts is physical location, separate from warehouse
    // ============================================================================
    
    function autoAdjustChannelAllocations(product, sourceChannel = null) {
        if (!product) return { adjusted: false, changes: [], parAlerts: [] };
        
        // Initialize channels if missing
        if (!product.channels) {
            product.channels = {};
        }
        
        const adjustments = {
            adjusted: false,
            changes: [],
            parAlerts: []
        };
        
        // Get warehouse qty (try multiple field names)
        const warehouseQty = product.warehouseQty || product.qty || product.quantity || 0;
        const channels = product.channels;
        
        // Available for online = warehouse qty (TM is separate physical location)
        const availableForOnline = warehouseQty;
        
        // Rule 1: Etsy and Wix always sync together
        let etsyQty = parseInt(channels.etsy) || 0;
        let wixQty = parseInt(channels.wix) || 0;
        
        if (sourceChannel === 'etsy') {
            // Sale from Etsy - sync Wix to match
            if (wixQty !== etsyQty && wixQty > 0) {
                adjustments.changes.push({ channel: 'wix', from: wixQty, to: etsyQty, reason: 'sync with etsy sale' });
                channels.wix = etsyQty;
                wixQty = etsyQty;
                adjustments.adjusted = true;
            }
        } else if (sourceChannel === 'wix') {
            // Sale from Wix - sync Etsy to match
            if (etsyQty !== wixQty && etsyQty > 0) {
                adjustments.changes.push({ channel: 'etsy', from: etsyQty, to: wixQty, reason: 'sync with wix sale' });
                channels.etsy = wixQty;
                etsyQty = wixQty;
                adjustments.adjusted = true;
            }
        } else {
            // Sale from Wayfair or other - ensure Etsy = Wix (use lower value)
            const syncedQty = Math.min(etsyQty, wixQty);
            if (etsyQty > 0 && etsyQty !== syncedQty) {
                adjustments.changes.push({ channel: 'etsy', from: etsyQty, to: syncedQty, reason: 'sync etsy=wix' });
                channels.etsy = syncedQty;
                adjustments.adjusted = true;
            }
            if (wixQty > 0 && wixQty !== syncedQty) {
                adjustments.changes.push({ channel: 'wix', from: wixQty, to: syncedQty, reason: 'sync etsy=wix' });
                channels.wix = syncedQty;
                adjustments.adjusted = true;
            }
            etsyQty = wixQty = syncedQty;
        }
        
        // Rule 2: Cap Etsy/Wix at available online (warehouse qty)
        const currentEtsyWix = parseInt(channels.etsy) || 0;
        if (currentEtsyWix > availableForOnline) {
            adjustments.changes.push({ channel: 'etsy', from: currentEtsyWix, to: availableForOnline, reason: 'exceeds warehouse' });
            adjustments.changes.push({ channel: 'wix', from: currentEtsyWix, to: availableForOnline, reason: 'exceeds warehouse' });
            channels.etsy = availableForOnline;
            channels.wix = availableForOnline;
            adjustments.adjusted = true;
        }
        
        // Rule 3: Cap Wayfair at available online
        const wayfairQty = parseInt(channels.wayfair) || 0;
        if (wayfairQty > availableForOnline) {
            adjustments.changes.push({ channel: 'wayfair', from: wayfairQty, to: availableForOnline, reason: 'exceeds warehouse' });
            channels.wayfair = availableForOnline;
            adjustments.adjusted = true;
        }
        
        // Clean up zero allocations
        ['etsy', 'wix', 'wayfair'].forEach(ch => {
            if (channels[ch] === 0) {
                delete channels[ch];
            }
        });
        
        // Rule 4: Check Channel PAR (Etsy/Wix)
        const finalEtsyWix = parseInt(channels.etsy) || 0;
        if (product.channelParEnabled && product.channelParMin > 0) {
            if (finalEtsyWix <= product.channelParMin) {
                adjustments.parAlerts.push({
                    type: 'channelPar',
                    message: `Channel PAR Alert: ${product.sku || 'Item'} - Etsy/Wix at ${finalEtsyWix} (min: ${product.channelParMin})`,
                    current: finalEtsyWix,
                    min: product.channelParMin
                });
                // Send notification
                sendParAlert(product, 'channel', finalEtsyWix, product.channelParMin);
            }
        }
        
        // Rule 5: Check Master PAR
        if (product.minParLevel > 0 && warehouseQty < product.minParLevel) {
            adjustments.parAlerts.push({
                type: 'masterPar',
                message: `Reorder Alert: ${product.sku || 'Item'} - Warehouse at ${warehouseQty} (min: ${product.minParLevel})`,
                current: warehouseQty,
                min: product.minParLevel
            });
        }
        
        return adjustments;
    }
    
    /**
     * Send PAR alert notification via email
     */
    function sendParAlert(product, alertType, currentQty, parLevel) {
        const sku = product.sku || product.SKU || 'Unknown';
        const productName = product.productName || product.title || product.name || 'Unknown';
        
        let subject, message;
        
        if (alertType === 'master') {
            subject = `‚ö†Ô∏è Reorder Alert: ${sku}`;
            message = `${productName} (${sku}) is below reorder point.\n\nCurrent Qty: ${currentQty}\nMin PAR: ${parLevel}\n\nPlease reorder soon.`;
        } else if (alertType === 'channel') {
            subject = `‚ö†Ô∏è Channel PAR Alert: ${sku}`;
            message = `${productName} (${sku}) - Etsy/Wix display qty is at trigger level.\n\nCurrent: ${currentQty}\nMin: ${parLevel}\n\nConsider adjusting channel allocation.`;
        }
        
        // Send to Google Apps Script proxy for email notification
        sendEventNotification(
            alertType === 'master' ? 'par.reorder' : 'par.channel_low',
            message,
            {
                sku: sku,
                productName: productName,
                alertType: alertType,
                currentQty: currentQty,
                minPar: parLevel
            }
        );
        
        // Also add to notification queue for UI display
        if (state.notifications) {
            state.notifications.push({
                id: Date.now(),
                type: 'warning',
                title: subject,
                message: message,
                timestamp: new Date().toISOString()
            });
        }
        
        console.log(`[PAR Alert] ${alertType}: ${sku} at ${currentQty} (min: ${parLevel})`);
    }
    
    /**
     * Send event to Google Apps Script proxy for email notification
     * Connects to your existing v1.3.0 proxy
     * v3.10.1 - Added 2026-01-21
     * Note: Email enabled/disabled is controlled by proxy settings (toggle in Email Settings UI)
     */
    async function sendEventNotification(eventType, message, data) {
        const config = configData || {};
        const settings = config.settings || {};
        
        // Get values from existing CONFIG structure
        const proxyUrl = config.syncHubProxyUrl || settings.proxyUrls?.syncHub;
        const apiKey = config.ccdApiKey || settings.ccdApiKey;
        
        // Check if proxy is configured
        if (!proxyUrl) {
            console.warn('[Email] Sync Hub proxy URL not set in CONFIG (settings.proxyUrls.syncHub)');
            return false;
        }
        
        if (!apiKey) {
            console.warn('[Email] ccdApiKey not set in CONFIG (settings.ccdApiKey)');
            return false;
        }
        
        try {
            console.log(`[Email] Sending ${eventType} event to proxy...`);
            
            // Build URL with parameters (GET request to work around CORS)
            // Google Apps Script redirects cause CORS issues with POST
            const params = new URLSearchParams({
                action: 'pushEvent',
                key: apiKey,
                eventType: eventType,
                source: 'sync_hub',
                message: message,
                data: JSON.stringify(data || {})
            });
            
            const requestUrl = `${proxyUrl}?${params.toString()}`;
            
            // Use dynamic script injection (JSONP-style) for guaranteed CORS bypass
            return new Promise((resolve) => {
                const callbackName = 'emailCallback_' + Date.now();
                const timeout = setTimeout(() => {
                    delete window[callbackName];
                    if (script.parentNode) script.parentNode.removeChild(script);
                    console.warn('[Email] ‚ö†Ô∏è Request timed out (but email may still be sent)');
                    resolve(true);
                }, 10000);
                
                window[callbackName] = function(result) {
                    clearTimeout(timeout);
                    delete window[callbackName];
                    if (script.parentNode) script.parentNode.removeChild(script);
                    
                    if (result && result.success) {
                        console.log(`[Email] ‚úÖ Event sent successfully (${result.notificationType || 'notification'})`);
                        resolve(true);
                    } else {
                        console.error('[Email] ‚ùå Proxy returned error:', result?.error || 'Unknown error');
                        resolve(false);
                    }
                };
                
                const fullUrl = `${requestUrl}&callback=${callbackName}`;
                const script = document.createElement('script');
                script.src = fullUrl;
                script.onerror = () => {
                    clearTimeout(timeout);
                    delete window[callbackName];
                    if (script.parentNode) script.parentNode.removeChild(script);
                    console.log('[Email] Script load failed, trying fetch backup...');
                    
                    fetch(requestUrl, { mode: 'no-cors' })
                        .then(() => {
                            console.log('[Email] ‚úÖ Backup fetch completed (email likely sent)');
                            resolve(true);
                        })
                        .catch(() => {
                            console.warn('[Email] ‚ö†Ô∏è Both methods failed');
                            resolve(false);
                        });
                };
                
                document.head.appendChild(script);
            });
            
        } catch (error) {
            console.warn('[Email] ‚ö†Ô∏è Failed to send notification:', error.message);
            return false;
        }
    }
    
    // =============================================
    // DATA INTEGRITY & VALIDATION (GAP 8, 9, 10)
    // v3.10.0 - Added 2026-01-21
    // =============================================
    
    /**
     * GAP 8: SKU VALIDATION
     * Validate that all SKUs in order exist in inventory
     * Feature Flag: enableSKUValidation (default: false for backward compatibility)
     */
    async function validateOrderSKUs(order) {
        // Check feature flag
        const config = configData || {};
        const enabled = config?.features?.enableSKUValidation ?? false;
        
        if (!enabled) {
            console.log('[SKU Validation] Feature disabled - skipping validation');
            return { valid: true, invalidSKUs: [], message: 'Validation disabled' };
        }
        
        console.log('[SKU Validation] Checking SKUs for order:', order.id);
        
        // Ensure we have Master JSON loaded
        if (!masterJsonData || !masterJsonData.inventory) {
            console.warn('[SKU Validation] Master JSON not loaded - cannot validate');
            return { valid: true, invalidSKUs: [], message: 'Master JSON not loaded' };
        }
        
        const products = getProductsArray();
        const invalidSKUs = [];
        
        // Check each item in the order
        for (const item of order.items) {
            const sku = item.sku;
            
            // Skip UNKNOWN SKUs (these are already flagged elsewhere)
            if (sku === 'UNKNOWN') continue;
            
            // Try to find product
            const product = products.find(p => (p.sku || p.SKU) === sku);
            
            if (!product) {
                invalidSKUs.push({
                    sku: sku,
                    title: item.title || 'Unknown Product',
                    quantity: item.qty || item.quantity || 1
                });
            }
        }
        
        // Return results
        if (invalidSKUs.length > 0) {
            const skuList = invalidSKUs.map(i => i.sku).join(', ');
            const message = `Order contains ${invalidSKUs.length} invalid SKU(s): ${skuList}`;
            
            console.error('[SKU Validation] ‚ùå Validation failed:', message);
            
            return {
                valid: false,
                invalidSKUs: invalidSKUs,
                message: message
            };
        }
        
        console.log('[SKU Validation] ‚úÖ All SKUs valid');
        return {
            valid: true,
            invalidSKUs: [],
            message: 'All SKUs valid'
        };
    }
    
    /**
     * GAP 9: DUPLICATE ORDER PREVENTION
     * Check if order has already been processed
     * Feature Flag: enableDuplicateDetection (default: false for backward compatibility)
     */
    async function isOrderProcessed(orderId) {
        // Check feature flag
        const config = configData || {};
        const enabled = config?.features?.enableDuplicateDetection ?? false;
        
        if (!enabled) {
            console.log('[Duplicate Detection] Feature disabled - allowing processing');
            return false; // Allow processing (old behavior)
        }
        
        console.log('[Duplicate Detection] Checking if order already processed:', orderId);
        
        // Check in-memory set first (fast)
        if (state.orders.processedIds.has(orderId)) {
            console.log('[Duplicate Detection] ‚ö†Ô∏è Found in memory cache');
            return true;
        }
        
        // Check Master JSON _processedOrders array (persistent)
        if (masterJsonData && masterJsonData._processedOrders) {
            const processed = masterJsonData._processedOrders.find(o => o.orderId === orderId);
            
            if (processed) {
                console.log('[Duplicate Detection] ‚ö†Ô∏è Order already processed:', {
                    orderId: orderId,
                    processedAt: processed.processedAt,
                    processedBy: processed.processedBy,
                    device: processed.device
                });
                
                // Add to memory cache for future checks
                state.orders.processedIds.add(orderId);
                
                return true;
            }
        }
        
        console.log('[Duplicate Detection] ‚úÖ Order not yet processed');
        return false;
    }
    
    /**
     * Mark order as processed in Master JSON (GAP 9)
     */
    async function persistProcessedOrder(order) {
        // Check feature flag
        const config = configData || {};
        const enabled = config?.features?.enableDuplicateDetection ?? false;
        
        if (!enabled) {
            console.log('[Duplicate Detection] Feature disabled - not marking order');
            return;
        }
        
        console.log('[Duplicate Detection] Marking order as processed:', order.id);
        
        // Add to memory cache
        state.orders.processedIds.add(order.id);
        
        // Add to Master JSON persistent list
        if (!masterJsonData._processedOrders) {
            masterJsonData._processedOrders = [];
        }
        
        // Create processed order record
        const record = {
            orderId: order.id,
            channel: order.channel,
            processedAt: new Date().toISOString(),
            processedBy: 'Sync Hub v3.10.1',
            device: localStorage.getItem('ccd_hostname') || 'Unknown',
            totalAmount: order.total || 0,
            itemCount: order.items?.length || 0
        };
        
        masterJsonData._processedOrders.push(record);
        
        // Trim to last 10,000 orders to prevent bloat
        if (masterJsonData._processedOrders.length > 10000) {
            console.log('[Duplicate Detection] Trimming processed orders list from', 
                masterJsonData._processedOrders.length, 'to 10,000');
            masterJsonData._processedOrders = masterJsonData._processedOrders.slice(-10000);
        }
        
        console.log('[Duplicate Detection] ‚úÖ Order marked as processed');
    }
    
    /**
     * Load processed order IDs from Master JSON on startup
     */
    function loadProcessedOrderIds() {
        if (masterJsonData && masterJsonData._processedOrders) {
            console.log('[Duplicate Detection] Loading processed order IDs from Master JSON');
            state.orders.processedIds.clear();
            
            for (const record of masterJsonData._processedOrders) {
                state.orders.processedIds.add(record.orderId);
            }
            
            console.log('[Duplicate Detection] Loaded', state.orders.processedIds.size, 'processed order IDs');
        }
    }
    
    /**
     * GAP 10: QUANTITY VALIDATION
     * Validate that channel allocations don't exceed warehouse quantity
     * Feature Flag: enableQuantityValidation (default: false for backward compatibility)
     */
    function validateChannelAllocations(product, proposedAllocations = null) {
        // Check feature flag
        const config = configData || {};
        const enabled = config?.features?.enableQuantityValidation ?? false;
        
        if (!enabled) {
            console.log('[Qty Validation] Feature disabled - skipping validation');
            return { valid: true, message: 'Validation disabled' };
        }
        
        console.log('[Qty Validation] Checking allocations for:', product.sku || product.SKU);
        
        // Use proposed allocations or current ones
        const allocations = proposedAllocations || product.channels || {};
        
        // Get warehouse quantity (try different field names)
        const warehouseQty = product.warehouseQty || product.qty || product.quantity || 0;
        
        // Get channel quantities
        const etsyQty = allocations.etsy || 0;
        const wixQty = allocations.wix || 0;
        const wayfairQty = allocations.wayfair || 0;
        
        const totalOnline = etsyQty + wixQty + wayfairQty;
        
        if (totalOnline > warehouseQty) {
            const message = 
                `Cannot allocate ${totalOnline} items online when only ` +
                `${warehouseQty} in warehouse.\n\n` +
                `Breakdown:\n` +
                `- Etsy: ${etsyQty}\n` +
                `- Wix: ${wixQty}\n` +
                `- Wayfair: ${wayfairQty}\n` +
                `- Total Online: ${totalOnline}\n` +
                `- Warehouse: ${warehouseQty}\n` +
                `- Overage: ${totalOnline - warehouseQty}`;
            
            console.warn('[Qty Validation] ‚ùå Invalid allocation:', message);
            
            return {
                valid: false,
                message: message,
                details: {
                    warehouse: warehouseQty,
                    etsy: etsyQty,
                    wix: wixQty,
                    wayfair: wayfairQty,
                    total: totalOnline,
                    overage: totalOnline - warehouseQty
                }
            };
        }
        
        console.log('[Qty Validation] ‚úÖ Allocations valid');
        return { valid: true, message: 'Allocations valid' };
    }
    
    /**
     * Process a single order - deduct inventory and cascade to other channels
     * Supports collision detection with auto-retry for auto-process mode
     * NOW INCLUDES: SKU validation (GAP 8) and Duplicate detection (GAP 9)
     */
    async function processOrder(orderId, isAutoProcess = false) {
        const order = state.orders.all.find(o => o.id === orderId);
        if (!order) {
            toast('Order not found', 'error');
            return;
        }
        
        if (!masterJsonData) {
            toast('Please connect Master JSON file first', 'error');
            return;
        }
        
        // ====== GAP 9: DUPLICATE ORDER DETECTION ======
        const alreadyProcessed = await isOrderProcessed(orderId);
        if (alreadyProcessed) {
            // Show warning toast
            toast(
                `‚ö†Ô∏è Order ${orderId} has already been processed!\n\n` +
                `This is a duplicate. Inventory was already deducted.\n` +
                `Skipping to prevent double-processing.`,
                'warning',
                8000
            );
            
            // Log the duplicate attempt
            addLog(`‚ö†Ô∏è Duplicate order blocked: ${orderId} (already processed)`, 'warning');
            
            // Mark in UI but don't process
            order.status = 'duplicate';
            order.processed = true;
            updateOrdersDisplay();
            
            return;
        }
        
        // ====== GAP 8: SKU VALIDATION ======
        const validation = await validateOrderSKUs(order);
        if (!validation.valid) {
            // Mark order as failed with clear error
            order.status = 'failed';
            order.error = validation.message;
            
            // Log the failure
            addLog(`‚ùå Order ${orderId} failed: ${validation.message}`, 'error');
            
            // Show detailed error to user
            const skuList = validation.invalidSKUs.map(i => 
                `‚Ä¢ ${i.sku} (${i.title}) - Qty: ${i.quantity}`
            ).join('\n');
            
            toast(
                `‚ùå Cannot process order: Invalid SKUs found\n\n` +
                `${skuList}\n\n` +
                `Please add these SKUs to inventory first.`,
                'error',
                10000
            );
            
            updateOrdersDisplay();
            return;
        }
        
        // Auto-process retry logic with collision handling
        let attempts = 0;
        const maxAttempts = 3;
        
        while (attempts < maxAttempts) {
            attempts++;
            
            addLog(`Processing order ${orderId}...${attempts > 1 ? ` (attempt ${attempts}/${maxAttempts})` : ''}`, 'info');
            
            const products = getProductsArray();
            const updates = [];
            const changes = []; // For change log
            const cascadeQueue = [];
            
            // ===== GAP 3: INVENTORY DEDUCTION WRAPPER =====
            // Check if inventory deduction is enabled via feature flag
            const config = configData || {};
            const enableDeduction = config.settings?.features?.inventoryDeduction ?? true; // Default TRUE for backward compatibility
            
            console.log(`[GAP 3] Processing order ${orderId}`);
            console.log(`[GAP 3] Inventory deduction: ${enableDeduction ? 'ENABLED' : 'DISABLED'}`);
            
            // Process each line item
            for (const item of order.items) {
                const sku = item.sku;
                if (sku === 'UNKNOWN') continue;
                
                // Find product in Master JSON
                const product = products.find(p => (p.sku || p.SKU) === sku);
                
                if (!product) {
                    addLog(`‚ö†Ô∏è SKU ${sku} not found in Master JSON`, 'warning');
                    continue;
                }
                
                // Declare variables outside conditional blocks for proper scoping
                let currentQty = product.warehouseQty || product.qty || product.quantity || 0;
                let newQty = currentQty;
                let adjustResult = { adjusted: false, changes: [], parAlerts: [] };
                
                // ===== INVENTORY DEDUCTION (CONDITIONAL - GAP 3) =====
                if (enableDeduction) {
                    // Calculate new quantity
                    newQty = Math.max(0, currentQty - item.qty);
                    
                    console.log(`[GAP 3] Deducting ${item.qty} from ${sku}: ${currentQty} ‚Üí ${newQty}`);
                    
                    // Check if sold out - send notification
                    if (currentQty > 0 && newQty === 0) {
                        sendEventNotification(
                            'inventory.soldout',
                            `${product.productName || product.title || sku} is now sold out`,
                            {
                                sku: sku,
                                productName: product.productName || product.title || 'Unknown',
                                previousQty: currentQty,
                                deductedQty: item.qty
                            }
                        );
                    }
                    
                    // Update the product
                    if (product.warehouseQty !== undefined) {
                        product.warehouseQty = newQty;
                    } else if (product.qty !== undefined) {
                        product.qty = newQty;
                    } else {
                        product.quantity = newQty;
                    }
                    
                    // v2.1.0: Auto-adjust channel allocations after order
                    adjustResult = autoAdjustChannelAllocations(product, order.channel);
                    if (adjustResult.adjusted) {
                        addLog(`üîÑ Auto-adjusted channels for ${sku}: ${adjustResult.changes.map(c => `${c.channel} ${c.from}‚Üí${c.to}`).join(', ')}`, 'info');
                    }
                    
                    updates.push({
                        sku: sku,
                        oldQty: currentQty,
                        newQty: newQty,
                        deducted: item.qty,
                        channelAdjustments: adjustResult.changes || []
                    });
                    
                    // Add to change log
                    changes.push({
                        changeType: 'order',
                        sku: sku,
                        field: 'qty',
                        before: currentQty,
                        after: newQty,
                        reason: `Order ${orderId} from ${order.channel}`,
                        user: isAutoProcess ? 'auto-process' : (localStorage.getItem('ccd_hostname') || 'Unknown')
                    });
                    
                    // Log deduction to activity log
                    logActivity('inventory', 'order_deduction', order.channel,
                        `Deducted ${item.qty} units of ${sku} for order ${orderId}`,
                        { 
                            sku: sku, 
                            quantity: item.qty, 
                            oldQty: currentQty, 
                            newQty: newQty, 
                            orderId: orderId,
                            channel: order.channel 
                        }
                    );
                } else {
                    console.log(`[GAP 3] Skipping deduction for ${sku} (feature disabled)`);
                    addLog(`‚ö†Ô∏è Inventory deduction disabled - ${sku} not deducted`, 'info');
                }
                // ===== END INVENTORY DEDUCTION =====
                
                // Queue updates for OTHER channels
                const sourceChannel = order.channel;
                
                // If has Etsy listing and order wasn't from Etsy
                if ((product.etsyListing || product.etsyListingId) && sourceChannel !== 'etsy') {
                    cascadeQueue.push({
                        channel: 'etsy',
                        sku: sku,
                        qty: newQty,
                        listingId: product.etsyListing || product.etsyListingId
                    });
                }
                
                // If has Wix product and order wasn't from Wix
                if ((product.wixProductId || product.wixId) && sourceChannel !== 'wix') {
                    cascadeQueue.push({
                        channel: 'wix',
                        sku: sku,
                        qty: newQty,
                        productId: product.wixProductId || product.wixId
                    });
                }
                
                // If has Wayfair SKU and order wasn't from Wayfair
                if ((product.wayfairSku || product.supplierPartNumber) && sourceChannel !== 'wayfair') {
                    cascadeQueue.push({
                        channel: 'wayfair',
                        sku: sku,
                        qty: newQty,
                        wayfairSku: product.wayfairSku || product.supplierPartNumber
                    });
                }
                
                // Check for low stock and PAR alerts
                const parLevel = product.parLevel || product.par || product.minParLevel || 0;
                if (parLevel > 0 && newQty < parLevel) {
                    addLog(`‚ö†Ô∏è LOW STOCK: ${sku} now at ${newQty} (PAR: ${parLevel})`, 'warning');
                    // Send PAR alert notification
                    sendParAlert(product, 'master', newQty, parLevel);
                }
                
                // Check channel PAR alerts (handled in autoAdjustChannelAllocations)
                if (adjustResult.parAlerts && adjustResult.parAlerts.length > 0) {
                    for (const alert of adjustResult.parAlerts) {
                        addLog(`‚ö†Ô∏è ${alert.message}`, 'warning');
                    }
                }
            }
            
            // Save Master JSON with collision detection
            if (updates.length > 0) {
                const saveResult = await saveMasterJson({
                    isAutoProcess: isAutoProcess,
                    actionDescription: `Order ${orderId}: ${updates.map(u => u.sku).join(', ')}`,
                    changes: changes
                });
                
                // Handle collision retry for auto-process
                if (saveResult && typeof saveResult === 'object' && saveResult.reason === 'collision_reload') {
                    if (attempts < maxAttempts) {
                        addLog(`üîÑ Collision retry ${attempts}/${maxAttempts} for order ${orderId}`, 'warning');
                        continue; // Retry with fresh data
                    } else {
                        addLog(`‚ùå Max collision retries exceeded for order ${orderId}`, 'error');
                        toast('Failed to save - max collision retries exceeded', 'error');
                        return;
                    }
                }
                
                if (saveResult === true) {
                    for (const u of updates) {
                        addLog(`‚úÖ ${u.sku}: ${u.oldQty} ‚Üí ${u.newQty} (-${u.deducted})`, 'success');
                    }
                    // Success - break out of retry loop
                    break;
                } else if (saveResult === false) {
                    // User cancelled or other error
                    toast('Order processing cancelled', 'info');
                    return;
                }
            } else {
                // No updates needed
                break;
            }
        }
        
        // Add cascade updates to queue
        // v4.0: Use channel-specific quantities from auto-adjustment
        const products = getProductsArray();
        const cascadeQueue = [];
        
        for (const item of order.items) {
            const sku = item.sku;
            if (sku === 'UNKNOWN') continue;
            
            const product = products.find(p => (p.sku || p.SKU) === sku);
            if (!product) continue;
            
            const sourceChannel = order.channel;
            const channels = product.channels || {};
            
            // v4.0: Push channel-specific qty (after auto-adjustment), not warehouse qty
            if ((product.etsyListing || product.etsyListingId) && sourceChannel !== 'etsy') {
                const etsyQty = channels.etsy || 0;
                cascadeQueue.push({
                    channel: 'etsy',
                    sku: sku,
                    qty: etsyQty,
                    listingId: product.etsyListing || product.etsyListingId
                });
            }
            
            if ((product.wixProductId || product.wixId) && sourceChannel !== 'wix') {
                const wixQty = channels.wix || 0;
                cascadeQueue.push({
                    channel: 'wix',
                    sku: sku,
                    qty: wixQty,
                    productId: product.wixProductId || product.wixId
                });
            }
            
            if ((product.wayfairSku || product.supplierPartNumber) && sourceChannel !== 'wayfair') {
                const wayfairQty = channels.wayfair || 0;
                cascadeQueue.push({
                    channel: 'wayfair',
                    sku: sku,
                    qty: wayfairQty,
                    wayfairSku: product.wayfairSku || product.supplierPartNumber
                });
            }
        }
        
        for (const cascade of cascadeQueue) {
            const queueItem = {
                id: Date.now() + Math.random(),
                type: 'inventory-sync',
                channel: cascade.channel,
                product: { sku: cascade.sku, ...cascade },
                fields: { quantity: true },
                status: 'pending',
                timestamp: new Date().toISOString(),
                reason: `Cascade from ${order.channel} order ${orderId}`
            };
            state.queue.push(queueItem);
        }
        
        if (cascadeQueue.length > 0) {
            await saveQueue();
            addLog(`üì§ Queued ${cascadeQueue.length} inventory updates to other channels`, 'info');
            
            // Log cascade queued to activity log
            logActivity('sync', 'cascade_queued', order.channel,
                `Queued ${cascadeQueue.length} channel updates from ${order.channel} order ${orderId}`,
                { 
                    orderId: orderId,
                    sourceChannel: order.channel,
                    cascadeCount: cascadeQueue.length,
                    targets: cascadeQueue.map(c => ({ channel: c.channel, sku: c.sku, qty: c.qty }))
                }
            );
            
            // ========== AUTO-PROCESS CASCADE IMMEDIATELY ==========
            // Don't wait for the 5-minute interval - process now!
            setTimeout(async () => {
                if (!state.processing) {
                    addLog('‚ö° Auto-processing cascade updates immediately...', 'info');
                    await processQueue();
                }
            }, 1000); // 1 second delay to let UI update
        }
        
        // Mark order as processed
        markOrderProcessed(orderId);
        
        // ====== GAP 9: PERSIST TO MASTER JSON ======
        await persistProcessedOrder(order);
        
        // Log order processed to activity log
        const itemsSummary = order.items.map(i => `${i.sku}(${i.qty})`).join(', ');
        logActivity('order', 'order_processed', order.channel,
            `Order ${orderId} processed - inventory deducted`,
            { 
                orderId: orderId,
                channel: order.channel,
                items: order.items?.map(i => ({ sku: i.sku, qty: i.qty })),
                isAutoProcess: isAutoProcess
            }
        );
        
        // Re-check low stock
        checkLowStock();
        
        // Update stats
        updateStats();
        renderQueue();
        
        // Send order processed notification
        sendEventNotification(
            'order.created',
            `Order processed from ${order.channel}`,
            {
                orderId: orderId,
                channel: order.channel,
                sku: order.items?.[0]?.sku || 'Multiple',
                productName: order.items?.[0]?.title || 'Multiple items',
                qty: order.items?.reduce((sum, item) => sum + (item.qty || 1), 0) || 0,
                total: order.total || 0
            }
        );
        
        // Send wayfair.sync notification specifically for Wayfair orders
        if (order.channel === 'wayfair') {
            sendEventNotification(
                'wayfair.sync',
                `Wayfair order ${orderId} synced to inventory`,
                {
                    orderId: orderId,
                    items: order.items?.map(i => ({ sku: i.sku, qty: i.qty, title: i.title })),
                    total: order.total || 0
                }
            );
        }
        
        toast(`Order ${orderId} processed successfully`, 'success');
    }
    
    /**
     * Mark order as processed without deducting inventory
     */
    function markOrderProcessed(orderId) {
        state.orders.processedIds.add(orderId);
        
        // Update in all arrays
        const updateOrder = (arr) => {
            const order = arr.find(o => o.id === orderId);
            if (order) order.processed = true;
        };
        
        updateOrder(state.orders.all);
        updateOrder(state.orders.etsy);
        updateOrder(state.orders.wix);
        updateOrder(state.orders.wayfair);
        
        // Save processed IDs to localStorage
        localStorage.setItem('ccd_processed_orders', JSON.stringify([...state.orders.processedIds]));
        
        updateOrderStats();
        renderOrders();
    }
    
    /**
     * Process all pending orders
     */
    async function processAllOrders() {
        const pending = state.orders.all.filter(o => !o.processed);
        
        if (pending.length === 0) {
            toast('No pending orders to process', 'info');
            return;
        }
        
        if (!confirm(`Process ${pending.length} orders and deduct inventory?`)) {
            return;
        }
        
        addLog(`Processing ${pending.length} orders...`, 'info');
        
        for (const order of pending) {
            await processOrder(order.id);
        }
        
        toast(`Processed ${pending.length} orders`, 'success');
    }
    
    /**
     * Load processed order IDs from localStorage
     */
    function loadProcessedOrders() {
        try {
            const saved = localStorage.getItem('ccd_processed_orders');
            if (saved) {
                state.orders.processedIds = new Set(JSON.parse(saved));
            }
        } catch (e) {
            console.warn('Could not load processed orders:', e);
        }
    }

    // =============================================
    // AUTO-SYNC FUNCTIONS - v3.9
    // =============================================
    
    /**
     * Toggle Auto-Poll feature
     */
    function toggleAutoPoll() {
        const enabled = document.getElementById('autoPollEnabled').checked;
        state.settings.autoPollEnabled = enabled;
        
        if (enabled) {
            startAutoPoll();
            addAutoSyncLogEntry('‚úÖ Auto-Poll enabled - polling every ' + state.settings.autoPollIntervalMinutes + ' minutes');
        } else {
            stopAutoPoll();
            addAutoSyncLogEntry('‚èπÔ∏è Auto-Poll disabled');
        }
        
        updateAutoSyncStatusBadge();
        saveAutoSyncSettings();
    }
    
    /**
     * Toggle Auto-Push feature
     */
    function toggleAutoPush() {
        const enabled = document.getElementById('autoPushEnabled').checked;
        state.settings.autoPushEnabled = enabled;
        
        // Save channel selections
        state.settings.autoPushEtsy = document.getElementById('autoPushEtsy').checked;
        state.settings.autoPushWix = document.getElementById('autoPushWix').checked;
        state.settings.autoPushWayfair = document.getElementById('autoPushWayfair').checked;
        
        if (enabled) {
            // Take initial inventory snapshot for change detection
            takeInventorySnapshot();
            // Start watching for changes
            startAutoPushWatcher();
            addAutoSyncLogEntry('‚úÖ Auto-Push enabled for: ' + getEnabledPushChannels().join(', '));
        } else {
            stopAutoPushWatcher();
            addAutoSyncLogEntry('‚èπÔ∏è Auto-Push disabled');
        }
        
        updateAutoSyncStatusBadge();
        saveAutoSyncSettings();
    }
    
    /**
     * Take a snapshot of current inventory quantities for change detection
     */
    function takeInventorySnapshot() {
        if (!masterJsonData) {
            console.log('[Auto-Push] No master JSON data to snapshot');
            return;
        }
        
        const products = getProductsArray();
        state.inventorySnapshot = {};
        
        for (const product of products) {
            const sku = product.sku || product.SKU || '';
            if (sku) {
                state.inventorySnapshot[sku] = {
                    qty: product.qty || product.quantity || product.totalQty || 0,
                    etsyQty: product.channels?.etsy || 0,
                    wixQty: product.channels?.wix || 0,
                    wayfairQty: product.channels?.wayfair || 0
                };
            }
        }
        
        console.log(`[Auto-Push] Snapshot taken: ${Object.keys(state.inventorySnapshot).length} products`);
    }
    
    /**
     * Start the auto-push file watcher
     */
    function startAutoPushWatcher() {
        if (state.autoPushWatchInterval) {
            clearInterval(state.autoPushWatchInterval);
        }
        
        // Track last processed change timestamp
        let lastProcessedChange = localStorage.getItem('ccd_sync_hub_last_processed_change') || '';
        
        // Check for changes every 10 seconds (faster for real-time sync)
        state.autoPushWatchInterval = setInterval(async () => {
            if (!state.settings.autoPushEnabled) return;
            
            try {
                // METHOD 1: Check localStorage for Inventory System changes (immediate)
                const lastChange = localStorage.getItem('ccd_inventory_last_change') || '';
                if (lastChange && lastChange !== lastProcessedChange) {
                    console.log('[Auto-Push] Detected Inventory System change via localStorage');
                    
                    const pendingChanges = JSON.parse(localStorage.getItem('ccd_inventory_changes') || '[]');
                    if (pendingChanges.length > 0) {
                        await processInventorySystemChanges(pendingChanges);
                        
                        // Clear processed changes
                        localStorage.setItem('ccd_inventory_changes', '[]');
                        lastProcessedChange = lastChange;
                        localStorage.setItem('ccd_sync_hub_last_processed_change', lastChange);
                    }
                }
                
                // METHOD 2: Check Master JSON file for external changes (if connected)
                if (masterJsonFileHandle) {
                    const file = await masterJsonFileHandle.getFile();
                    if (file.lastModified !== loadedFileTimestamp) {
                        console.log('[Auto-Push] Master JSON file changed, checking for inventory updates...');
                        
                        // Store old snapshot
                        const oldSnapshot = state.inventorySnapshot || {};
                        
                        // Reload the file
                        await loadMasterJson();
                        
                        // Detect changes and queue pushes
                        await detectAndQueueChanges(oldSnapshot);
                    }
                }
            } catch (error) {
                console.error('[Auto-Push] Watch error:', error);
                if (state.settings.alertSyncErrors) {
                    addAutoSyncLogEntry(`‚ùå Auto-push watch error: ${error.message}`);
                }
            }
        }, 10000); // Check every 10 seconds for faster response
        
        console.log('[Auto-Push] File watcher started (10s interval)');
    }
    
    /**
     * v3.9: Process changes from Inventory System via localStorage
     */
    async function processInventorySystemChanges(changes) {
        let queuedCount = 0;
        
        for (const change of changes) {
            const sku = change.sku;
            addAutoSyncLogEntry(`üîÑ Processing change from Inventory System: ${sku}`);
            
            // Queue Etsy update if qty changed and has listing ID
            if (state.settings.autoPushEtsy && 
                change.etsyListingId && 
                change.changes.channels.etsy.old !== change.changes.channels.etsy.new) {
                
                addToQueue({
                    channel: 'etsy',
                    action: 'update',
                    product: {
                        sku: sku,
                        productName: change.productName,
                        qty: change.changes.channels.etsy.new,
                        listingId: change.etsyListingId
                    },
                    fields: { quantity: true },
                    reason: `Inventory System: Etsy qty ${change.changes.channels.etsy.old} ‚Üí ${change.changes.channels.etsy.new}`,
                    source: 'inventory-system-auto-push'
                });
                queuedCount++;
            }
            
            // Queue Wix update if qty changed and has product ID
            if (state.settings.autoPushWix && 
                change.wixProductId && 
                change.changes.channels.wix.old !== change.changes.channels.wix.new) {
                
                addToQueue({
                    channel: 'wix',
                    action: 'update',
                    product: {
                        sku: sku,
                        productName: change.productName,
                        qty: change.changes.channels.wix.new,
                        productId: change.wixProductId
                    },
                    fields: { quantity: true },
                    reason: `Inventory System: Wix qty ${change.changes.channels.wix.old} ‚Üí ${change.changes.channels.wix.new}`,
                    source: 'inventory-system-auto-push'
                });
                queuedCount++;
            }
            
            // Queue Wayfair update if qty changed and has Wayfair SKU
            if (state.settings.autoPushWayfair && 
                change.wayfairSku && 
                change.changes.channels.wayfair.old !== change.changes.channels.wayfair.new) {
                
                addToQueue({
                    channel: 'wayfair',
                    action: 'update',
                    product: {
                        sku: sku,
                        productName: change.productName,
                        qty: change.changes.channels.wayfair.new,
                        wayfairSku: change.wayfairSku
                    },
                    fields: { quantity: true },
                    reason: `Inventory System: Wayfair qty ${change.changes.channels.wayfair.old} ‚Üí ${change.changes.channels.wayfair.new}`,
                    source: 'inventory-system-auto-push'
                });
                queuedCount++;
            }
            
            // Check for zero stock alert
            if (state.settings.alertZeroStock && 
                change.changes.warehouseQty.new === 0 && 
                change.changes.warehouseQty.old > 0) {
                addAutoSyncLogEntry(`‚ö†Ô∏è ZERO STOCK: ${sku} (was ${change.changes.warehouseQty.old})`);
                toast(`Zero Stock Alert: ${sku}`, 'warning');
            }
        }
        
        if (queuedCount > 0) {
            addAutoSyncLogEntry(`üì§ Queued ${queuedCount} channel updates from Inventory System`);
            toast(`Auto-Push: Queued ${queuedCount} updates`, 'info');
            
            // Auto-process the queue
            if (!state.processing) {
                addAutoSyncLogEntry('üöÄ Auto-processing queue...');
                await processQueue();
            }
        }
    }
    
    /**
     * Stop the auto-push file watcher
     */
    function stopAutoPushWatcher() {
        if (state.autoPushWatchInterval) {
            clearInterval(state.autoPushWatchInterval);
            state.autoPushWatchInterval = null;
        }
        console.log('[Auto-Push] File watcher stopped');
    }
    
    /**
     * Detect inventory changes and queue items for push
     */
    async function detectAndQueueChanges(oldSnapshot) {
        const products = getProductsArray();
        const changedItems = [];
        
        for (const product of products) {
            const sku = product.sku || product.SKU || '';
            if (!sku) continue;
            
            const oldData = oldSnapshot[sku];
            const newQty = product.qty || product.quantity || product.totalQty || 0;
            const newEtsyQty = product.channels?.etsy || 0;
            const newWixQty = product.channels?.wix || 0;
            const newWayfairQty = product.channels?.wayfair || 0;
            
            // Check if this is a new product or quantities changed
            if (!oldData || 
                oldData.qty !== newQty ||
                oldData.etsyQty !== newEtsyQty ||
                oldData.wixQty !== newWixQty ||
                oldData.wayfairQty !== newWayfairQty) {
                
                changedItems.push({
                    product: product,
                    oldQty: oldData?.qty || 0,
                    newQty: newQty,
                    channels: {
                        etsy: { old: oldData?.etsyQty || 0, new: newEtsyQty },
                        wix: { old: oldData?.wixQty || 0, new: newWixQty },
                        wayfair: { old: oldData?.wayfairQty || 0, new: newWayfairQty }
                    }
                });
            }
        }
        
        if (changedItems.length === 0) {
            addAutoSyncLogEntry('‚úì No inventory changes detected');
            takeInventorySnapshot(); // Update snapshot
            return;
        }
        
        addAutoSyncLogEntry(`üîÑ Detected ${changedItems.length} inventory changes`);
        
        // Queue pushes for each enabled channel
        let queuedCount = 0;
        
        for (const change of changedItems) {
            const product = change.product;
            const sku = product.sku || product.SKU || '';
            
            // Queue for Etsy if enabled and quantity changed
            if (state.settings.autoPushEtsy && change.channels.etsy.old !== change.channels.etsy.new) {
                if (product.etsyListingId || product.etsy?.listingId) {
                    addToQueue({
                        channel: 'etsy',
                        action: 'update',
                        product: {
                            sku: sku,
                            productName: product.productName || product.name || sku,
                            qty: change.channels.etsy.new,
                            listingId: product.etsyListingId || product.etsy?.listingId
                        },
                        fields: { quantity: true },
                        reason: `Auto-push: qty ${change.channels.etsy.old} ‚Üí ${change.channels.etsy.new}`,
                        source: 'auto-push'
                    });
                    queuedCount++;
                }
            }
            
            // Queue for Wix if enabled and quantity changed
            if (state.settings.autoPushWix && change.channels.wix.old !== change.channels.wix.new) {
                if (product.wixProductId || product.wix?.productId) {
                    addToQueue({
                        channel: 'wix',
                        action: 'update',
                        product: {
                            sku: sku,
                            productName: product.productName || product.name || sku,
                            qty: change.channels.wix.new,
                            productId: product.wixProductId || product.wix?.productId
                        },
                        fields: { quantity: true },
                        reason: `Auto-push: qty ${change.channels.wix.old} ‚Üí ${change.channels.wix.new}`,
                        source: 'auto-push'
                    });
                    queuedCount++;
                }
            }
            
            // Queue for Wayfair if enabled and quantity changed
            if (state.settings.autoPushWayfair && change.channels.wayfair.old !== change.channels.wayfair.new) {
                if (product.wayfairSku || product.wayfair?.sku) {
                    addToQueue({
                        channel: 'wayfair',
                        action: 'update',
                        product: {
                            sku: sku,
                            productName: product.productName || product.name || sku,
                            qty: change.channels.wayfair.new,
                            wayfairSku: product.wayfairSku || product.wayfair?.sku
                        },
                        fields: { quantity: true },
                        reason: `Auto-push: qty ${change.channels.wayfair.old} ‚Üí ${change.channels.wayfair.new}`,
                        source: 'auto-push'
                    });
                    queuedCount++;
                }
            }
            
            // Check for zero stock alert
            if (state.settings.alertZeroStock && change.newQty === 0 && change.oldQty > 0) {
                addAutoSyncLogEntry(`‚ö†Ô∏è ZERO STOCK: ${sku} (was ${change.oldQty})`);
                toast(`Zero Stock Alert: ${sku}`, 'warning');
            }
        }
        
        // Update snapshot with new data
        takeInventorySnapshot();
        
        if (queuedCount > 0) {
            addAutoSyncLogEntry(`üì§ Queued ${queuedCount} channel updates`);
            toast(`Auto-Push: Queued ${queuedCount} updates`, 'info');
            
            // Auto-process the queue
            if (!state.processing) {
                addAutoSyncLogEntry('üöÄ Auto-processing queue...');
                await processQueue();
            }
        } else {
            addAutoSyncLogEntry('‚ÑπÔ∏è Changes detected but no linked channels to update');
        }
    }
    
    /**
     * Get list of enabled push channels
     */
    function getEnabledPushChannels() {
        const channels = [];
        if (state.settings.autoPushEtsy) channels.push('Etsy');
        if (state.settings.autoPushWix) channels.push('Wix');
        if (state.settings.autoPushWayfair) channels.push('Wayfair');
        return channels;
    }
    
    /**
     * Update the poll interval setting
     */
    function updateAutoPollInterval() {
        const minutes = parseInt(document.getElementById('autoPollInterval').value);
        state.settings.autoPollIntervalMinutes = minutes;
        
        if (state.settings.autoPollEnabled) {
            stopAutoPoll();
            startAutoPoll();
            addAutoSyncLogEntry('üîÑ Poll interval changed to ' + minutes + ' minutes');
        }
        
        saveAutoSyncSettings();
    }
    
    /**
     * Start auto-polling with resilient recovery mechanisms
     */
    function startAutoPoll() {
        // Clear any existing polling
        stopAutoPoll();
        
        const intervalMs = state.settings.autoPollIntervalMinutes * 60 * 1000;
        const intervalMinutes = state.settings.autoPollIntervalMinutes;
        
        console.log(`[AutoPoll] Starting resilient polling every ${intervalMinutes} minutes`);
        
        // Strategy 1: Web Worker Timer (not throttled by browser)
        try {
            const workerCode = `
                let intervalId = null;
                let intervalMs = ${intervalMs};
                
                self.onmessage = function(e) {
                    if (e.data.command === 'start') {
                        intervalMs = e.data.intervalMs || intervalMs;
                        if (intervalId) clearInterval(intervalId);
                        
                        // Immediate tick
                        self.postMessage({ type: 'tick', timestamp: Date.now() });
                        
                        // Then regular interval
                        intervalId = setInterval(() => {
                            self.postMessage({ type: 'tick', timestamp: Date.now() });
                        }, intervalMs);
                    } else if (e.data.command === 'stop') {
                        if (intervalId) {
                            clearInterval(intervalId);
                            intervalId = null;
                        }
                    }
                };
            `;
            
            const blob = new Blob([workerCode], { type: 'application/javascript' });
            state.autoPollWorker = new Worker(URL.createObjectURL(blob));
            
            state.autoPollWorker.onmessage = async (e) => {
                if (e.data.type === 'tick') {
                    console.log('[AutoPoll] Worker tick received');
                    await performAutoPoll();
                }
            };
            
            state.autoPollWorker.onerror = (err) => {
                console.error('[AutoPoll] Worker error:', err);
                // Fall back to regular interval
                startFallbackPolling(intervalMs);
            };
            
            state.autoPollWorker.postMessage({ command: 'start', intervalMs });
            console.log('[AutoPoll] Web Worker timer started');
            
        } catch (e) {
            console.warn('[AutoPoll] Web Worker not available, using fallback:', e);
            startFallbackPolling(intervalMs);
        }
        
        // Strategy 2: Watchdog timer (checks if polling is happening)
        startPollWatchdog();
        
        // Strategy 3: Visibility change listener (recover when tab becomes visible)
        setupVisibilityRecovery();
        
        // Update UI
        document.getElementById('autoPollStatus').style.display = 'block';
        state.lastPollTime = Date.now();
        updatePollCountdown();
        
        addAutoSyncLogEntry(`‚úÖ Resilient auto-poll started (${intervalMinutes} min interval)`);
    }
    
    /**
     * Fallback polling using regular setInterval
     */
    function startFallbackPolling(intervalMs) {
        console.log('[AutoPoll] Using fallback setInterval polling');
        
        // Perform immediate poll
        performAutoPoll();
        
        // Set up interval
        state.autoPollInterval = setInterval(() => {
            performAutoPoll();
        }, intervalMs);
    }
    
    /**
     * Watchdog timer - checks if polling is happening and recovers if not
     */
    function startPollWatchdog() {
        // Check every 2 minutes if polling is still happening
        const watchdogIntervalMs = 2 * 60 * 1000;
        
        // Max allowed gap = poll interval + 2 minutes buffer
        const maxGapMs = (state.settings.autoPollIntervalMinutes + 2) * 60 * 1000;
        
        state.autoPollWatchdog = setInterval(() => {
            const autoPollEnabled = document.getElementById('autoPollEnabled')?.checked;
            if (!autoPollEnabled || !state.lastPollTime) return;
            
            const timeSinceLastPoll = Date.now() - state.lastPollTime;
            const minutesSinceLastPoll = Math.round(timeSinceLastPoll / 60000);
            
            console.log(`[Watchdog] Last poll was ${minutesSinceLastPoll} minutes ago`);
            
            if (timeSinceLastPoll > maxGapMs) {
                console.warn(`[Watchdog] Polling gap detected! ${minutesSinceLastPoll} minutes since last poll`);
                
                // Show warning
                showPollWarning(minutesSinceLastPoll);
                
                // Attempt recovery
                addAutoSyncLogEntry(`‚ö†Ô∏è Polling gap detected (${minutesSinceLastPoll} min). Auto-recovering...`);
                
                // Force an immediate poll
                performAutoPoll();
                
                // Restart the polling system
                stopAutoPoll();
                setTimeout(() => {
                    startAutoPoll();
                    addAutoSyncLogEntry(`‚úÖ Auto-poll recovered successfully`);
                }, 1000);
            }
        }, watchdogIntervalMs);
        
        console.log('[Watchdog] Started - checking every 2 minutes');
    }
    
    /**
     * Set up visibility change recovery
     */
    function setupVisibilityRecovery() {
        document.removeEventListener('visibilitychange', handleVisibilityChange);
        document.addEventListener('visibilitychange', handleVisibilityChange);
        console.log('[AutoPoll] Visibility recovery listener added');
    }
    
    /**
     * Handle visibility change - recover polling when tab becomes visible
     */
    async function handleVisibilityChange() {
        if (document.visibilityState === 'visible') {
            const autoPollEnabled = document.getElementById('autoPollEnabled')?.checked;
            if (!autoPollEnabled) return;
            
            const timeSinceLastPoll = state.lastPollTime ? Date.now() - state.lastPollTime : Infinity;
            const maxGapMs = (state.settings.autoPollIntervalMinutes + 1) * 60 * 1000;
            
            if (timeSinceLastPoll > maxGapMs) {
                const minutesSinceLastPoll = Math.round(timeSinceLastPoll / 60000);
                console.log(`[Visibility] Tab became visible after ${minutesSinceLastPoll} min gap. Recovering...`);
                
                addAutoSyncLogEntry(`üëÅÔ∏è Tab became visible after ${minutesSinceLastPoll} min. Catching up...`);
                hidePollWarning();
                
                // Perform immediate poll
                await performAutoPoll();
                
                // Restart polling system to resync timer
                stopAutoPoll();
                setTimeout(() => {
                    startAutoPoll();
                }, 500);
            }
        }
    }
    
    /**
     * Update the countdown display
     */
    function updatePollCountdown() {
        const intervalMs = state.settings.autoPollIntervalMinutes * 60 * 1000;
        const nextPollTime = (state.lastPollTime || Date.now()) + intervalMs;
        
        if (state.autoPollCountdown) {
            clearInterval(state.autoPollCountdown);
        }
        
        state.autoPollCountdown = setInterval(() => {
            const remaining = Math.max(0, nextPollTime - Date.now());
            const mins = Math.floor(remaining / 60000);
            const secs = Math.floor((remaining % 60000) / 1000);
            
            const statusText = document.getElementById('autoPollStatusText');
            if (statusText) {
                statusText.textContent = `Next poll in: ${mins}:${secs.toString().padStart(2, '0')}`;
            }
        }, 1000);
    }
    
    /**
     * Show polling gap warning banner
     */
    function showPollWarning(minutesSinceLastPoll) {
        if (state.pollGapWarningShown) return;
        state.pollGapWarningShown = true;
        
        let banner = document.getElementById('pollWarningBanner');
        if (!banner) {
            banner = document.createElement('div');
            banner.id = 'pollWarningBanner';
            banner.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                background: linear-gradient(90deg, #ff6b6b, #ee5a5a);
                color: white;
                padding: 12px 20px;
                text-align: center;
                font-weight: 600;
                z-index: 10000;
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 15px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            `;
            banner.innerHTML = `
                <span>‚ö†Ô∏è <strong>Polling Gap Detected!</strong> Last poll was <span id="pollGapMinutes">${minutesSinceLastPoll}</span> minutes ago. Orders may have been missed.</span>
                <button onclick="window.recoverPollingManually()" style="background:white;color:#ee5a5a;border:none;padding:8px 16px;border-radius:6px;cursor:pointer;font-weight:600;">üîÑ Recover Now</button>
                <button onclick="window.hidePollWarning()" style="background:transparent;color:white;border:1px solid white;padding:8px 12px;border-radius:6px;cursor:pointer;">‚úï</button>
            `;
            document.body.prepend(banner);
        } else {
            const gapSpan = document.getElementById('pollGapMinutes');
            if (gapSpan) gapSpan.textContent = minutesSinceLastPoll;
            banner.style.display = 'flex';
        }
    }
    
    /**
     * Hide polling gap warning banner
     */
    function hidePollWarning() {
        state.pollGapWarningShown = false;
        const banner = document.getElementById('pollWarningBanner');
        if (banner) {
            banner.style.display = 'none';
        }
    }
    window.hidePollWarning = hidePollWarning;
    
    /**
     * Manual recovery button handler
     */
    async function recoverPollingManually() {
        hidePollWarning();
        addAutoSyncLogEntry(`üîÑ Manual polling recovery initiated...`);
        
        await performAutoPoll();
        
        const wasEnabled = document.getElementById('autoPollEnabled')?.checked;
        if (wasEnabled) {
            stopAutoPoll();
            setTimeout(() => {
                startAutoPoll();
                addAutoSyncLogEntry(`‚úÖ Polling recovered and restarted`);
                toast('Polling recovered successfully', 'success');
            }, 500);
        }
    }
    window.recoverPollingManually = recoverPollingManually;
    
    /**
     * Stop auto-polling completely
     */
    function stopAutoPoll() {
        // Stop Web Worker
        if (state.autoPollWorker) {
            state.autoPollWorker.postMessage({ command: 'stop' });
            state.autoPollWorker.terminate();
            state.autoPollWorker = null;
        }
        
        // Stop fallback interval
        if (state.autoPollInterval) {
            clearInterval(state.autoPollInterval);
            state.autoPollInterval = null;
        }
        
        // Stop countdown
        if (state.autoPollCountdown) {
            clearInterval(state.autoPollCountdown);
            state.autoPollCountdown = null;
        }
        
        // Stop watchdog
        if (state.autoPollWatchdog) {
            clearInterval(state.autoPollWatchdog);
            state.autoPollWatchdog = null;
        }
        
        // Remove visibility listener
        document.removeEventListener('visibilitychange', handleVisibilityChange);
        
        // Hide warning if shown
        hidePollWarning();
        
        // Update UI
        document.getElementById('autoPollStatus').style.display = 'none';
        
        console.log('[AutoPoll] All polling stopped');
    }
    
    /**
     * Perform an auto-poll operation
     */
    async function performAutoPoll() {
        // Record poll time BEFORE polling (so watchdog knows we're trying)
        state.lastPollTime = Date.now();
        hidePollWarning();
        
        const timestamp = new Date().toLocaleTimeString();
        addAutoSyncLogEntry(`üì• [${timestamp}] Auto-polling orders...`);
        
        try {
            // Use existing pullOrdersFromChannels but with shorter time range
            const pullEtsy = document.getElementById('pullEtsy').checked;
            const pullWix = document.getElementById('pullWix').checked;
            const pullWayfair = document.getElementById('pullWayfair').checked;
            
            // Calculate time range (last poll interval + buffer)
            const endDate = new Date();
            const startDate = new Date(endDate.getTime() - (state.settings.autoPollIntervalMinutes + 5) * 60 * 1000);
            
            let totalOrders = 0;
            let channels = [];
            
            if (pullEtsy && state.settings.enableEtsySync && state.settings.etsyProxyUrl) {
                try {
                    const result = await pullEtsyOrders(startDate, endDate);
                    if (result.success && result.orders) {
                        totalOrders += result.orders.length;
                        if (result.orders.length > 0) channels.push(`Etsy: ${result.orders.length}`);
                    }
                } catch (e) {
                    if (state.settings.alertSyncErrors) {
                        addAutoSyncLogEntry(`‚ùå Etsy poll error: ${e.message}`);
                    }
                }
            }
            
            if (pullWix && state.settings.enableWixSync && state.settings.wixProxyUrl) {
                try {
                    const result = await pullWixOrders(startDate, endDate);
                    if (result.success && result.orders) {
                        totalOrders += result.orders.length;
                        if (result.orders.length > 0) channels.push(`Wix: ${result.orders.length}`);
                    }
                } catch (e) {
                    if (state.settings.alertSyncErrors) {
                        addAutoSyncLogEntry(`‚ùå Wix poll error: ${e.message}`);
                    }
                }
            }
            
            if (pullWayfair && state.settings.enableWayfairSync && state.settings.wayfairProxyUrl) {
                try {
                    const result = await pullWayfairOrders(startDate, endDate);
                    if (result.success && result.orders) {
                        totalOrders += result.orders.length;
                        if (result.orders.length > 0) channels.push(`Wayfair: ${result.orders.length}`);
                    }
                } catch (e) {
                    if (state.settings.alertSyncErrors) {
                        addAutoSyncLogEntry(`‚ùå Wayfair poll error: ${e.message}`);
                    }
                }
            }
            
            if (totalOrders > 0) {
                addAutoSyncLogEntry(`‚úÖ Found ${totalOrders} new orders (${channels.join(', ')})`);
                toast(`Auto-Poll: Found ${totalOrders} new orders`, 'success');
                
                // Auto-process if enabled
                if (state.settings.autoProcessEnabled) {
                    await processQueue();
                }
            } else {
                addAutoSyncLogEntry(`‚úì No new orders found`);
            }
            
            // Update poll time after successful completion
            state.lastPollTime = Date.now();
            updatePollCountdown();
            
        } catch (error) {
            addAutoSyncLogEntry(`‚ùå Auto-poll failed: ${error.message}`);
            if (state.settings.alertSyncErrors) {
                toast('Auto-poll error: ' + error.message, 'error');
            }
        }
    }
    
    /**
     * Add entry to auto-sync log
     */
    function addAutoSyncLogEntry(message) {
        const timestamp = new Date().toLocaleString();
        state.autoSyncLog.unshift({ timestamp, message });
        
        // Keep only last 100 entries
        if (state.autoSyncLog.length > 100) {
            state.autoSyncLog = state.autoSyncLog.slice(0, 100);
        }
        
        renderAutoSyncLog();
    }
    
    /**
     * Render the auto-sync log
     */
    function renderAutoSyncLog() {
        const container = document.getElementById('autoSyncLog');
        if (!container) return;
        
        if (state.autoSyncLog.length === 0) {
            container.innerHTML = '<div style="color: var(--text-dim); text-align: center;">Auto-sync log will appear here when enabled.</div>';
            return;
        }
        
        container.innerHTML = state.autoSyncLog.slice(0, 20).map(entry => {
            let color = 'var(--text-dim)';
            if (entry.message.includes('‚úÖ')) color = 'var(--success)';
            else if (entry.message.includes('‚ùå')) color = 'var(--error)';
            else if (entry.message.includes('‚ö†Ô∏è')) color = 'var(--warning)';
            
            return `<div style="color: ${color}; margin-bottom: 4px;">${entry.message}</div>`;
        }).join('');
    }
    
    /**
     * Clear the auto-sync log
     */
    function clearAutoSyncLog() {
        state.autoSyncLog = [];
        renderAutoSyncLog();
        toast('Auto-sync log cleared', 'success');
    }
    
    /**
     * Update the auto-sync status badge
     */
    function updateAutoSyncStatusBadge() {
        const badge = document.getElementById('autoSyncStatusBadge');
        if (!badge) return;
        
        const pollEnabled = state.settings.autoPollEnabled;
        const pushEnabled = state.settings.autoPushEnabled;
        
        if (pollEnabled && pushEnabled) {
            badge.textContent = 'FULL AUTO';
            badge.style.background = 'rgba(34,197,94,0.2)';
            badge.style.color = 'var(--success)';
        } else if (pollEnabled) {
            badge.textContent = 'AUTO-POLL';
            badge.style.background = 'rgba(59,130,246,0.2)';
            badge.style.color = 'var(--info)';
        } else if (pushEnabled) {
            badge.textContent = 'AUTO-PUSH';
            badge.style.background = 'rgba(168,85,247,0.2)';
            badge.style.color = '#a855f7';
        } else {
            badge.textContent = 'DISABLED';
            badge.style.background = 'rgba(239,68,68,0.2)';
            badge.style.color = 'var(--error)';
        }
    }
    
    /**
     * Save auto-sync settings to localStorage
     */
    function saveAutoSyncSettings() {
        const settings = {
            autoPollEnabled: state.settings.autoPollEnabled,
            autoPollIntervalMinutes: state.settings.autoPollIntervalMinutes,
            autoPushEnabled: state.settings.autoPushEnabled,
            autoPushEtsy: document.getElementById('autoPushEtsy')?.checked ?? true,
            autoPushWix: document.getElementById('autoPushWix')?.checked ?? true,
            autoPushWayfair: document.getElementById('autoPushWayfair')?.checked ?? true,
            alertZeroStock: document.getElementById('alertZeroStock')?.checked ?? true,
            alertMismatch: document.getElementById('alertMismatch')?.checked ?? true,
            alertSyncErrors: document.getElementById('alertSyncErrors')?.checked ?? true
        };
        
        // Update state
        Object.assign(state.settings, settings);
        
        localStorage.setItem('ccdSyncHubAutoSync', JSON.stringify(settings));
    }
    
    /**
     * Load auto-sync settings from localStorage
     */
    function loadAutoSyncSettings() {
        try {
            const saved = localStorage.getItem('ccdSyncHubAutoSync');
            if (saved) {
                const settings = JSON.parse(saved);
                Object.assign(state.settings, settings);
                
                // Update UI
                const autoPollEnabled = document.getElementById('autoPollEnabled');
                const autoPollInterval = document.getElementById('autoPollInterval');
                const autoPushEnabled = document.getElementById('autoPushEnabled');
                const autoPushEtsy = document.getElementById('autoPushEtsy');
                const autoPushWix = document.getElementById('autoPushWix');
                const autoPushWayfair = document.getElementById('autoPushWayfair');
                const alertZeroStock = document.getElementById('alertZeroStock');
                const alertMismatch = document.getElementById('alertMismatch');
                const alertSyncErrors = document.getElementById('alertSyncErrors');
                
                if (autoPollEnabled) autoPollEnabled.checked = settings.autoPollEnabled || false;
                if (autoPollInterval) autoPollInterval.value = settings.autoPollIntervalMinutes || 15;
                if (autoPushEnabled) autoPushEnabled.checked = settings.autoPushEnabled || false;
                if (autoPushEtsy) autoPushEtsy.checked = settings.autoPushEtsy !== false;
                if (autoPushWix) autoPushWix.checked = settings.autoPushWix !== false;
                if (autoPushWayfair) autoPushWayfair.checked = settings.autoPushWayfair !== false;
                if (alertZeroStock) alertZeroStock.checked = settings.alertZeroStock !== false;
                if (alertMismatch) alertMismatch.checked = settings.alertMismatch !== false;
                if (alertSyncErrors) alertSyncErrors.checked = settings.alertSyncErrors !== false;
                
                // Start auto-poll if it was enabled
                if (settings.autoPollEnabled) {
                    startAutoPoll();
                }
                
                // Start auto-push watcher if it was enabled
                if (settings.autoPushEnabled) {
                    // Delay to allow Master JSON to connect first
                    setTimeout(() => {
                        if (masterJsonFileHandle && masterJsonData) {
                            takeInventorySnapshot();
                            startAutoPushWatcher();
                            addAutoSyncLogEntry('‚úÖ Auto-Push resumed from previous session');
                        } else {
                            addAutoSyncLogEntry('‚ö†Ô∏è Auto-Push enabled but Master JSON not connected yet');
                        }
                    }, 3000);
                }
                
                updateAutoSyncStatusBadge();
            }
        } catch (e) {
            console.warn('Could not load auto-sync settings:', e);
        }
    }

    // =============================================
    // START APP
    // =============================================
    document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
